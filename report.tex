\documentclass{ituthesis}
\usepackage[]{tikz} 
\usepackage[]{hyperref}
\usepackage[]{float} 
\usepackage[]{csquotes} 
\usepackage[]{graphicx} 
\usepackage[font={scriptsize}]{caption} 
\usepackage[]{subcaption} 
\usepackage[]{mdframed}
\usepackage[]{ntheorem} 
\usepackage[]{fixltx2e} 
\usepackage[]{mathpartir} 
\usepackage[]{syntax} 
\usepackage[utf8]{inputenc} 
\usepackage[]{listings} 
\usepackage[scaled=.8]{beramono} 
\usepackage[backend=bibtex, style=authoryear]{biblatex}
\bibliography{report.bib}

\lstset{basicstyle=\ttfamily}

\definecolor{constructor-color}{RGB}{155,187,89}
\definecolor{type-color}{RGB}{142,180,227}
\definecolor{declared-var-color}{RGB}{192,80,77}
\definecolor{local-var-color}{RGB}{230,185,184}
\definecolor{literal-color}{RGB}{179,162,199}

\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}

\newcommand{\ttconstructor}[1]{\textcolor{constructor-color}{\texttt{#1}}}
\newcommand{\tttype}[1]{\textcolor{type-color}{\texttt{#1}}}
\newcommand{\ttdec}[1]{\textcolor{declared-var-color}{\texttt{#1}}}
\newcommand{\ttvar}[1]{\textcolor{local-var-color}{\texttt{#1}}}
\newcommand{\ttliteral}[1]{\textcolor{literal-color}{\texttt{#1}}}

\theoremstyle{break}
\theorembodyfont{}
\newtheorem{exmp}{Example}
\newtheorem{alg}{Algorithm}

\newenvironment{asideblock}
  {\begin{mdframed}[style=0,%
      leftline=false,rightline=false,leftmargin=2em,rightmargin=2em,%
          innerleftmargin=0pt,innerrightmargin=0pt,linewidth=0.75pt,%
      skipabove=7pt,skipbelow=7pt]\small}
  {\end{mdframed}}

\settitle{The Practical Guide to Levitation}
\setauthor{Ahmad Salim Al-Sibahi}
\setsupervisor{Dr. Peter Sestoft}
\setextrasupervisor{David R. Christiansen}
\setdate{September 1, 2014}

\begin{document}
%\selectlanguage{danish}

\frontmatter

\thetitlepage
\newpage

\chapter*{Abstract}
Goal: Implementation of levitation in a realistic setting, with practical performance benefits.
\blockquote{DISCLAIMER: This is a draft and as such is incomplete, incorrect and can contain grammatical errors.
Although I claim originality of this report, many underlying ideas are based on current work in the scientific community which will be correctly attributed
when the work is complete.}

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter
\midsloppy
\sloppybottom
\chapter{Introduction}
\label{cha:Intoduction}
\section{Context}
\label{sec:Context}
Algebraic datatypes such as Boolean values, lists or trees form a core part of modern functional programming.
Most functions written work directly on such datatypes, but some functions like structural equality or pretty printing (see Example~\ref{exmp:prettyprint}) don't directly dependent on the datatype itself.
Therefore, writing such functions for each different datatype becomes a repetitive exercise.
In fact it is possible to write an algorithm over the structural definition of the datatype, which the computer then could use to derive an actual function for each particular datatypes.

\begin{exmp}
  Pretty printing an element of any algebraic data type follows a very simple procedure:
  \begin{enumerate}
    \item Print the name of the constructor
    \item Iterate over the constructor arguments and pretty print them, with each argument surrounded by parentheses if necessary
    \begin{enumerate}
      \item If the argument is a recursive reference to the type itself, then call this procedure recursively (starting at point 1).
      \item If the data element is of another type, then
      \begin{enumerate}
        \item Find the correct pretty printing function for that type
        \item Pretty print the field using the found function
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}
  \label{exmp:prettyprint}
\end{exmp}

Enter the world of \textit{generic programming} where the target datatype is the one describing the structure of other datatypes, often called the \textit{description}\label{kw:desc}.
While generic programming sounds promising, it is usually seen as an aspect of Haskell\,\autocite{haskell98} that is challenging to use by ordinary programmers. To represent the description, it is often required to use special language extensions\,\autocite{magalhaes2010generic,Jansson:1997:PPP:263699.263763} and the programming style tends to require different abstractions than when writing ordinary programs.

%A tiny bit of history here?
However, in dependently-typed languages such as Idris\,\autocite{brady2013idris} or Agda\,\autocite{norell2009dependently} it is possible to create a correct description using ordinary datatype definitions\,\autocite{benke2003universes}.
Furthermore, \textcite{Chapman:2010:GAL:1863543.1863547} show that it is possible to build a self-supporting closed type system which is able to convert these descriptions to ordinary types (creating so-called \textit{described types}), while still being powerful enough to describe the description datatype itself.
In such system, generic programming is just a special case of ordinary programming.

%\subsection{The Importance of Genericity in Dependently-typed Languages}
%\label{sub:TheImportanceofGenericityinDependently-typedLanguages}
%\textit{The similarity of structure and various slightly-different indexing of types.}


\section{Problem definition}
\label{sec:ProblemDefinition}
The current work on generic programming in dependently-typed languages presents both elegant and typesafe ways to represent the structural descriptions of datatypes.
Furthermore, it allows the programmer to save both time and boilerplate code while reducing mistakes by using ordinary programming techniques to do generic programming.

However, the state of the art is heavily theoretically oriented, which might lead to some challenges when a system needs to be developed with a practical audience in mind.
First of all, multiple description formats are often presented, sometimes even in the same paper, which might not be particularly attractive in a practical setting.
Secondly, there has been little work done on how to integrate such descriptions in languages which contain features such as type classes and proof scripts.
Finally, datatypes synthesised from descriptions create large canonical terms; thus, both type checking and runtime performance are very slow.
In the end, if an efficient and easily usable framework for programming with described types could be implemented successfully, it would save programmers both the time and effort required to write repetitive functions.

\section{Aim and scope}
\label{sec:AimandScope}
The aim of this research is to provide a practical and efficient implementation of described types in Idris.
This project has three primary goals.

The first goal is to find a good definition of the description that supports many common datatypes.
I mainly seek to reuse some of the existing work, and not to further develop underlying type theory to support more complex inductive families; neither will I focus on supporting all language features of Idris such as implicit arguments and codata definitions.

The second goal is to present realistic examples using generic functions working on described types. 
This mainly includes implementing functions that can be used to derive type class instances, and a Scrap Your Boilerplate-style (SYB) library for generic querying and traversal.

The final goal is to describe how partial evaluation and related techniques can be used to optimise the generic functions with regards to specific descriptions in order to achieve acceptable performance.
This includes using techniques such as polyvariant partial evaluation\,\autocite{Jones:1993:PEA:153676} and constructor specialisation\,\autocite{Mogensen:1993:CS:154630.154633}. %Elaborate when I know more about PE\ldots

\section{Significance}
\label{sec:Significance}
The main contributions of this thesis are:

\begin{itemize}
  \item an example-based tutorial for understanding described types in the context of a practical programming language, namely Idris;
    \item an explanation of the different definitions of parameters found in the literature;
    \item a procedure that generates descriptions from ordinary datatype declarations;
  \item an generic implementation of common operations such as decidable equality, pretty printing and functors, which can be used to provide default implementations to type class methods;
  \item a discussion of the challenges that arise when trying to implement a SYB-style generics library in dependently typed languages;
  \item design of an algorithm using optimisation techniques based on partial evaluation for reducing runtime size and time overhead for described types and accompanying generic functions.
\end{itemize}
\section{Overview}
\label{sec:Overview}

The report is structured as follows. Chapter~\ref{cha:GenericProgramming} presents an introduction to described types specifically focusing on recent developments using dependently-typed programming languages.
Chapter~\ref{cha:PartialEvaluation} presents an overview of techniques for partial evaluation of functions and specialisation of datatypes. Chapter~\ref{cha:LevitatingIdris} discusses specifically how I implemented described types in Idris and continues with practical examples in Chapter~\ref{cha:PracticalExamples}.
Chapter~\ref{cha:OptimizingIdrisforFlight} presents the optimisations that can be made in order to improve the runtime performance of described types and generic functions.
Finally, Chapter~\ref{cha:Discussion} discusses the challenges that still lie ahead and concludes the effort.
\chapter{Generic programming}
\label{cha:GenericProgramming}
\section{The generic structure of inductive data types}
\label{sec:TheGenericStructureofInductiveDataTypes}
\subsection{Anatomy of a datatype}
\label{sub:AnatomyofaDatatype}
To build an intuition that will be useful in understanding descriptions, let us first start by looking closely at how datatypes are structured.
Recall from Page~\pageref{kw:desc} that a description is a data value representing the structure of a particular datatype.
Figure~\ref{fig:anatomydatatype} presents an annotated version of a typical dependently-typed datatype representing vectors.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/AnatomyOfADatatype.png}
\end{center}
\caption{Annotated components of a datatype Declaration}
\label{fig:anatomydatatype}
\end{figure}

A datatype consists of a type constructor which lists what type-level arguments are required, and zero or more data constructors which describe how to create values of the datatype.
The type constructor has three components: a name for the datatype, types of any possible parameters, and the types of possible indices.
In Figure~\ref{fig:anatomydatatype} there is no syntactic difference between a parameter type or an index type since Idris figures that out automatically
\footnote{If an argument to a type constructor doesn't change in the data constructor declarations, Idris considers it a parameter, otherwise an index.},
unlike other dependently-typed languages like Agda which have a syntactic distinction.

Similarly to the type constructor, a data constructor needs a name, also called a \textit{tag}.
Following the tag, the data constructor declaration contains the types of the arguments stored in the constructor and the resulting type that must use the type constructor of the datatype.
In our example two constructors are declared, \ttconstructor{Nil} and \ttconstructor{Cons}.
The constructor \ttconstructor{Nil} doesn't hold any data, so it only needs to define the resulting type which is \tttype{Vec}~\ttvar{a}~\ttconstructor{Z} (a vector with length \ttliteral{0}).
The constructor \ttconstructor{Cons} contains three different types of arguments: an ordinary implicit argument, an ordinary explicit argument, and an explicit argument of the type itself (recursive); the resulting type for \ttconstructor{Cons} is \tttype{Vec}~\ttvar{a}~\texttt{(}\ttconstructor{S}~\ttvar{n}\texttt{)}, that is, a vector of length \ttliteral{1}\texttt{+}\ttvar{n} where \ttvar{n} is the length of the recursive argument.

\begin{asideblock}
  The colouring scheme for code presented in this paper uses the following conventions:
  \begin{quote}
  \begin{description}
    \item[\tttype{Blue}] is used for type constructors
    \item[\ttconstructor{Green}] is used for data constructors
    \item[\ttdec{Dark Red}] is used for top-level declarations
    \item[\ttvar{Light Red}] is used for locally-bound variables
    \item[\ttliteral{Purple}] is used for literals (integer, string, etc.)
    \item[\texttt{\textbf{Bold Black}}] is used for keywords (if, data, etc.)
  \end{description}
  \end{quote}

\end{asideblock}

\subsection{A description for datatypes}
\label{sub:ADescriptionforDatatypes}
It is now possible to try to represent a suitable datatype for descriptions.
Figure~\ref{fig:descriptiondatatype} presents one possible solution, influenced mainly by the work of \textcite{mcbride2010ornamental} and \textcite{diehl2014eliminators}.
Similarly based on that work, Section~\ref{sec:SynthesisingDescriptionstoTypes} will later present how to construct actual described types from these descriptions.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ADescriptionforDatatypesSimple.png}
\end{center}
\caption{A datatype that describes other datatypes}
\label{fig:simpldescdatatype}
\end{figure}

The description datatype \tttype{Desc} has three main constructors:
\begin{itemize}
  \item  Constructor \ttconstructor{Ret} represents the end of a description
  \item  Constructor \ttconstructor{Arg} represents the addition of an argument of any type to a given description; the first argument of \ttconstructor{Arg} is the type of argument expected and the second argument is the rest of the description dependent on a value of that type.
  \item  Constructor \ttconstructor{Rec} represents a recursive argument of the described datatype. The argument of constructor \ttconstructor{Rec} is the specification of the rest of the description.
\end{itemize}

To get an idea on how descriptions for various interesting datatypes look like, the following paragraphs will show a series of examples providing a side-by-side comparison of ordinary declarations to descriptions.
The declaration of the trivial singleton type \tttype{Unit} is displayed in Figure~\ref{fig:declunit}, and its corresponding description is displayed in Figure~\ref{fig:descunit}.
Since the sole constructor \ttconstructor{MkUnit} doesn't contain any arguments, \ttconstructor{Ret} is used to simply end the description.

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Declaration of \tttype{Unit}\label{fig:declunit}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/UnitDeclaration.png}
}
\subcaptionbox{Description of \tttype{Unit}\label{fig:descunit}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/UnitDescription.png}

}
\caption{The \tttype{Unit} datatype and its description}
\end{center}
\end{figure}

\paragraph{Constructor arguments}
A more interesting datatype is displayed in Figure~\ref{fig:declpair}, namely the datatype \tttype{Pair} representing a pair of \tttype{Int} and \tttype{Bool}.
The translation to the corresponding description, as displayed in Figure~\ref{fig:descpair}, seems straightforward. 
For each argument of \ttconstructor{MkPair} that is used \texttt{(}\ttvar{arg}~\texttt{:}~\ttvar{a}\texttt{)~->}~\ttvar{b}, the translation would be of the form \ttconstructor{Arg}~\ttvar{a}~\texttt{(\textbackslash}\ttvar{arg}~\texttt{=>}~\ttvar{b}\texttt{)}.
Finally, to specify the end of the description, \ttconstructor{Ret} is used.

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Declaration of \tttype{Pair}\label{fig:declpair}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/PairDeclaration.png}
}
\subcaptionbox{Description of \tttype{Pair}\label{fig:descpair}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/PairDescription.png}

}
\caption{A pair of \tttype{Int} and \tttype{Bool}}
\end{center}
\end{figure}

A key aspect of algebraic datatypes is the ability to choose between multiple constructors.
Figure~\ref{fig:decleither} shows a simple datatype \tttype{Either} which provides two constructors \ttconstructor{Right} and \ttconstructor{Left}, than can hold a value of \tttype{Int} and \tttype{String} respectively.

\paragraph{Choice of constructors}
Since there is no explicit way to encode a choice between multiple constructor in the provided description, instead a boolean argument \ttvar{isRight} is used as a tag to determine which constructor is described.
If the value of \ttvar{isRight} is true then the resulting description is expected to be for the \ttconstructor{Right} constructor, otherwise
is is expected to be for the \ttconstructor{Left} constructor.
The description for each constructor is then specified in a similar fashion to datatypes with one constructor, such as \tttype{Pair} described above.

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Declaration of \tttype{Either}\label{fig:decleither}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/EitherDeclaration.png}
}
\subcaptionbox{Description of \tttype{Either}\label{fig:desceither}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/EitherDescription.png}

}
\caption{the sum type of \tttype{Int} and \tttype{String}}
\end{center}
\end{figure}

\paragraph{Recursive arguments}
In addition to allowing the choice between multiple possible constructors, what makes algebraic datatypes interesting is the ability to
have recursive (or \textit{inductive}) instances. The simplest recursive datatype is the natural numbers \tttype{Nat} (displayed in Figure~\ref{fig:declnat}) which has two constructors,
\ttconstructor{Zero} which represents \ttliteral{0} and the recursively defined \ttconstructor{Succ} which represents \ttliteral{1}+\ttvar{n} for any natural number \ttvar{n}.
The corresponding description is displayed in Figure~\ref{fig:descnat} which is mainly built up using the principles introduced before.
The only addition is that the description for \ttconstructor{Succ} now uses \ttconstructor{Rec} to specify that it requires a recursive argument (to type \tttype{Nat} itself).

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Declaration of \tttype{Nat}\label{fig:declnat}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/NatDeclaration.png}
}
\subcaptionbox{Description of \tttype{Nat}\label{fig:descnat}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/NatDescription.png}

}
\caption{The Natural numbers (\tttype{Nat})}
\end{center}
\end{figure}

\paragraph{Parameters}
Figure~\ref{fig:decllist} shows one of the classical datatypes in functional programming languages, namely \tttype{List}.
Unlike \tttype{Pair} and \tttype{Either} which were monomorphic in the presented examples, \tttype{List} is polymorphic in its elements.
The way to represent parameters is by having them as arguments to the function describing the particular datatype, which allows them to be qualified over the whole description.
The description itself is built using the previously described methods and is displayed in Figure~\ref{fig:desclist}. There is a Boolean argument \ttvar{isNil}, which encodes the choice between the two constructors of the list,
\ttconstructor{Nil} and \ttconstructor{Cons}.
Like the description for \ttconstructor{Zero}, the description for \ttconstructor{Nil} is simply \ttconstructor{Ret} since it doesn't accept any arguments.
The description for \ttconstructor{Cons} takes an argument of the parameter type (the head of the list), a recursive argument (the tail of the list) and then ends the description.

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Declaration of \tttype{List}\label{fig:decllist}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/ListDeclaration.png}
}
\subcaptionbox{Description of \tttype{List}\label{fig:desclist}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/ListDescription.png}

}
\caption{A polymorphic list of elements}
\end{center}
\end{figure}

The reader may have noticed that the datatypes presented so far are perfectly expressible in ordinary functional languages like Haskell or Standard ML\,\autocite{Milner:1997:DSM:549659}.
To really exploit the power of dependently-typed programming languages, it should be possible to express datatypes that may be indexed by values.
This will be discussed in Section~\ref{sub:Indexingdescriptions}.

\subsection{Indexing descriptions}
\label{sub:Indexingdescriptions}

To allow datatypes to be indexed by values, the description structure takes a parameter that describes what the type of indices must be.
Figure~\ref{fig:descriptiondatatype} shows an updated version of Figure~\ref{fig:simpldescdatatype}, that contains the necessary parameter \ttvar{ix} for indexing datatypes.
The constructors \ttconstructor{Ret} and \ttconstructor{Rec}, must also be updated to take a value of \ttvar{ix} in order to represent what the index of the result type and recursive argument must be respectively.
Descriptions that don't require indices can be converted to indexed descriptions by using the unit type \tttype{Unit} (or its syntactic form \tttype{()}) as index.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ADescriptionforDatatypes.png}
\end{center}
\caption{Description for datatypes with possible indices}
\label{fig:descriptiondatatype}
\end{figure}

To give an example on how an indexed datatype looks like, let us take a new look at \tttype{Vec} from Figure~\ref{fig:anatomydatatype}.
Figure~\ref{fig:descvec} shows the corresponding description of \tttype{Vec} with comparable annotations.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorDescription.png}
\end{center}
\caption{Described version of \tttype{Vec}}
\label{fig:descvec}
\end{figure}


The type signature for the description of \tttype{Vec} mimics the one for the actual datatype closely, but there are nonetheless some differences.
There is now an explicit distinction between parameters and indices; the type for a parameter can still be specified as an argument for the description value,
whereas the type of an index must be provided to the \tttype{Desc} type constructor.
This is to ensure that all provided indices conform to the same expected type, while still allowing the values to change inside the description.

A Boolean argument \ttvar{isNil} is used to describe the choice between constructors \ttconstructor{Nil} and \ttconstructor{Cons}.
The constructor \ttconstructor{Nil} doesn't contain any data so we simply use \ttconstructor{Ret~Z}, which indicates that the description is finished and the resulting type is expected to have index \ttconstructor{Z}, analogously to Figure~\ref{fig:anatomydatatype}.
The constructor \ttconstructor{Cons} takes first two ordinary arguments: a \tttype{Nat} representing the length of the tail, i.e. the index of the recursive argument, and an argument of the parameter type \ttvar{a} representing the head.
Following these arguments we take a recursive argument representing the tail---specified using \ttconstructor{Rec}---that must have the value of the input \tttype{Nat} argument \ttvar{n} as index, i.e. the argument must be of type \tttype{Vec}~\ttvar{a~n}.
We finish the description with \ttconstructor{Ret} and specify that the resulting index must be \ttconstructor{S}~\ttvar{n}, just as in Figure~\ref{fig:anatomydatatype}.

\subsubsection{Challenges and limitations}
Even though it was possible to describe a variety of datatypes there are still a few questions that can be raised, such as: How is it possible to choose between more than two constructors? Why is there only one type for indices?
Why aren't the type of parameters required to be encoded inside the description datatype itself? How is it possible to represent more complex datatypes such as mutual recursive ones? I seek to answer these questions in the following paragraphs.

To encode the choice of more than two constructors, a simple solution could be to nest multiple Boolean values acting as a form of binary enumeration of tags.
However this encoding is fairly crude: it does not capture important information such as the names of constructors, requires a series of possibly complicated tests and is not easily extendible if one wants to extend descriptions
with new constructors. In Section~\ref{sub:AnInformativeEncodingofConstructors}, I will present a more sophisticated encoding that doesn't suffer from these limitations.

For more demanding datatypes that need more than one index, the indices must be uncurried using dependent pairs.
For example, a datatype with signature \texttt{(}\ttvar{n}~\texttt{:}~\tttype{Nat}\texttt{)~->~}\tttype{Fin}~\ttvar{n}~\texttt{->}~\tttype{Type} must use the dependent pair \tttype{(}\ttvar{n}~\texttt{:}~\tttype{Nat}~\tttype{**}~\tttype{Fin}~\ttvar{n}\tttype{)} as the type of its index.

Since parameters are usually quantified over the whole datatype (\textit{i.e.}, they do not change) it is possible to just accept them as external arguments when building
a description.
However, this encoding can preclude interesting generic programs from being written, such as the functorial map. In Chapter~\ref{cha:LevitatingIdris}, I will discuss a modification to the description datatype that permits encoding the types of
parameters directly.

Finally, there is the question on how more complicated datatypes are to be represented.
Datatypes that require recursive functions as arguments like \tttype{Desc}, can not currently be represented in the presented encoding and the description must be extended to be able to describe types as itself (see Section~\ref{sec:TheMostlyGentleArtofLevitation}).
Mutual recursive datatypes cannot be represented directly, but it is possible to use indices to represent an isomorphic representation.
For example, for two mutually recursive datatypes one could use a boolean argument as index which determines the actual datatype is currently described.
Unfortunately, a challenge that still persists is that the most complex inductive families---such as inductive-inductive and inductive-recursive definitions---can not be represented using the presented descriptions.

\subsection{An informative encoding of constructors}
\label{sub:AnInformativeEncodingofConstructors}
In Section~\ref{sub:ADescriptionforDatatypes} a Boolean variable was used to determine the choice between two constructors, and concluded that his approach had multiple disadvantages.
First of all, the Boolean encoding does not capture the names of the respective constructors which might be important when it is desired to pretty print or serialise a data structure.
Secondly, when there are more than two constructors, it can quickly become complicated to provide a suitable description.
Multiple Boolean arguments are required and mapping these Boolean values to description is not exactly straightforward.
For example, should two Boolean values encode the choice between 3 or 4 constructors?
Finally, and perhaps more importantly, it is not easy to modify the number of constructors easily with the Boolean encoding. That is, it might be desirable to compute a new description from a provided one and in that process to add a new constructor,
\textit{e.g.}, adding a default ``error'' constructor to each datatype.
This section presents a more informative encoding of constructors, and shows how it is possible to use that encoding when describing non-trivial datatypes.

To represent which constructors are available we first are going to declare two types (heavily inspired by \textcite{Dagand2013acosmology,diehl2014eliminators}) as displayed in Figure~\ref{fig:ctorlabels}: \ttdec{CLabel} which represents a name for a constructor, and \ttdec{CEnum} which
represents a list of constructor names. For the sake of simplicity, the provided constructors in a \ttdec{CEnum} are assumed to be provided uniquely by the user, however one could stipulate such uniqueness condition explicitly if desired.
Figure~\ref{fig:vectctors} show an example of how to represent the available constructor names of \tttype{Vec}.


\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Representation\label{fig:ctorlabels}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/AnInformativeEncodingofConstructorsLabels.png}
}
\subcaptionbox{Example: Constructors of Vec\label{fig:vectctors}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/VectorConstructors.png}

}
\caption{Constructor labels}
\end{center}
\end{figure}

Now that it is possible to represent the available constructors, we can encode a way of choosing a particular constructor tag. Figure~\ref{fig:ctortags} shows a datatype \tttype{Tag} with two constructors:
\ttconstructor{TZ} which represents the constructor that is on top of the current list and \ttconstructor{TS} which represents a constructor further along the list. As such, \tttype{Tag} specifies a valid index into a (non-empty) list of constructor tags.

This encoding has multiple advantages: it ensures that all constructor labels stored in our data exist in the expected list of constructors, it ensures that all datatypes which are dependent on a tag must have at least one constructor, and as a consequence
it is possible to specify the empty type by simply requiring a tag on an empty list of expected constructors (since such value would be impossible to create).
This encoding makes it possible to use tactics in Idris to automate the retrieval of a tag given a constructor label; something which saves time when constructing
values manually.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/AnInformativeEncodingofConstructorsTags.png}
\end{center}
\caption{Tags: A Structure for Picking a Constructor from a Label Collection}
\label{fig:ctortags}
\end{figure}

For the constructors of \tttype{Vec}, Figure~\ref{fig:vecctor} shows an example on what the tag values are. For \ttconstructor{Nil} the value is \ttconstructor{TZ} since it is the first in the list of \ttdec{VecCtors}, and for \ttconstructor{Cons} the value
is \ttconstructor{TS~TZ} since it is the second. Since there are only two elements in \ttdec{VecCtors}, it shouldn't be possible to create any other valid constructor tag, and as therefore it is a good representative for enumerating the constructors of \tttype{Vec}.

\begin{figure}[ht]
\begin{center}
  \subcaptionbox{Tag for \ttconstructor{Nil}\label{fig:vecctornil}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/VectorNilTag.png}
}
\subcaptionbox{Tag for \ttconstructor{Cons}\label{fig:vecctorcons}}[.45\textwidth]{
    \includegraphics[scale=0.5]{Figures/VectorConsTag.png}

}
\caption{Example: Tags for constructors of \tttype{Vec}}
\label{fig:vecctor}
\end{center}
\end{figure}


\subsection{A constructive type of choice}
\label{sub:AConstructiveTypeofChoice}
Similarly to how \texttt{\textbf{if}} was used to map \tttype{Bool} values to the descriptions of the various constructors of a datatype in Section~\ref{sub:ADescriptionforDatatypes}, it is desirable to have a way
to map \tttype{Tag} values to suitable values of a desired type.  The following section will describe the \ttdec{switch} function that does exactly this.

Since the count of constructors for a datatype can vary in size, it is necessary to calculate a type that allows mapping the tag of each constructor to a suitable value (displayed in Figure~\ref{fig:smallpiop}). 
It is essentially a function that provides a one-to-one mapping from the list of constructors to a series of right-nested pairs ending with \tttype{()}.
The type of the resulting value \ttvar{prop} can be dependent on the input constructor tag, and therefore the function is called $\pi$ or the \textit{small pi operator}.
The operator $\pi$ is small in the sense that unlike the dependent function type $\Pi$ which allows the result to dependent on any type of input, $\pi$ only allows dependencies on constructor tags.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/AConstructiveTypeofChoice.png}
\end{center}
\caption{The small pi operator: type for case analysis based on constructor tags}
\label{fig:smallpiop}
\end{figure}

Given a way to map a list of constructors to a list of values using $\pi$, it is now possible to define \ttdec{switch} which can look up the corresponding result value in the map for a particular \tttype{Tag}.
The function \ttdec{switch} is displayed in Figure~\ref{fig:switchctor} and has two branches: if the constructor to map is the first one in a list of constructors, it simply returns the first value in the corresponding mapping, otherwise
it continues the search using the rest of the provided elements (skipping the first constructor and its corresponding mapping).
Since there can be no value of \tttype{Tag} on an empty enumeration of constructors, it is not required to handle that case.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/AConstructiveChoice.png}
\end{center}
\caption{Calculation of a property based on a specific constructor tag}
\label{fig:switchctor}
\end{figure}

As an example, Figure~\ref{fig:vecdescim} shows the description of \tttype{Vec} (from Figure~\ref{fig:descvec}) again, but this time using the new constructor tag encoding instead of a Boolean variable.

\begin{figure}[H]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorDescriptionImproved.png}
\end{center}
\caption{Description of Vec given a Constructor Tag}
\label{fig:vecdescim}
\end{figure}

In summary, while the description might initially seem more complicated than before, it has a couple of clear advantages: the encoding now contain the constructor tag and it is possible to choose between more than two constructors at the same time.

\section{Synthesising types from descriptions}
\label{sec:SynthesisingDescriptionstoTypes}
In Section~\ref{sec:TheGenericStructureofInductiveDataTypes} I had displayed how it was possible to create descriptions that support many common datatypes in Idris.
In this section I will present a way to convert or \textit{synthesise} these descriptions to actual types, that allows the programmer to construct values of these described types with actual data.

\subsection{Datatype synthesis}
\label{sub:DatatypeSynthesis}
It is finally time to convert the description to an actual type. Figure~\ref{fig:synthdata} shows the \ttdec{Synthesise} function which takes a description, the final form of that datatype and the resulting index, then it returns a type which can contain the described data.

\begin{itemize}
  \item If we reach the end of the description \textit{i.e.}, \ttconstructor{Ret}, the only thing that we need to ensure is that the provided resulting index matches the expected index provided in the description. In order to apply such constraint we use the propositional equality type.
  \item For recursive arguments \textit{i.e.}, \ttconstructor{Rec}, we construct a dependent pair where the first argument contains a value of the fully-synthesised type with the given index and the second argument contains the synthesised version of the rest of the provided description. The reason that we need the final form of the datatype in order to construct a recursive argument is due to the fact that if we call \ttdec{Synthesise} recursively on that argument we would get stuck in an infinite loop!
  \item For ordinary arguments \textit{i.e.}, \ttconstructor{Arg}, we also create a dependent pair. The first argument of the dependent pair is a value \ttvar{arg} of the provided type \ttvar{a}, and the second argument is the synthesis of the rest of the provided description \ttvar{d} given \ttvar{arg}. This is isomorphic to how an ordinary constructor would store the data and as such the dependent pair serves a good target structure for our synthesis.
\end{itemize}
Since the dependent pair is used as the target type for the synthesis, it itself must be a core part of the type theory similarly to the propositional equality, if we want to treat all datatype declarations as describable.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/SynthesisingData.png}
\end{center}
\caption{Synthesising Descriptions into Actual Types}
\label{fig:synthdata}
\end{figure}

We are able to actual types using \ttdec{Synthesise} from the provided descriptions.
However, a problem occurs when we want to use \ttdec{Synthesise} since it requires the final form of the described datatype as input but the only way to synthesise the datatype is using \ttdec{Synthesise} itself.
In order to ``tie the knot'' and complete input for \ttdec{Synthesise}, we define a datatype \tttype{Data} that takes a description and provides the final form of the described datatype (see Figure~\ref{fig:datafromdesc}).
\tttype{Data} has only one constructor namely \ttconstructor{Con} which takes as input the synthesised version of the description \ttvar{d} with \tttype{Data}~\ttvar{d} serving as argument for the final form of the datatype in \ttdec{Synthesise}. This works since each time we face a recursive argument it must be constructed using \ttconstructor{Con} which avoids an infinite loop in \ttdec{Synthesise} as long as the elements that are constructed are smaller in size.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TyingTheSynthesisKnot.png}
\end{center}
\caption{Knot-tying the Synthesised Description with Itself}
\label{fig:datafromdesc}
\end{figure}

\subsection{Example: Constructing vectors}
\label{sub:Example:Constructing Vectors}

To get a more concrete intuition on how it is possible to construct data values of described types, this section will look at the synthesised version of \tttype{Vec}.
Figure~\ref{fig:synthversvecdesc} shows \ttdec{Vec} which is a function mimicking its corresponding type constructor, and it even shares the same type signature.
The function \ttdec{Vec} returns a described type using \tttype{Desc} passing along the description of \tttype{Vec} and its required parameters (\textit{i.e.}, \ttdec{VecDesc}~\ttvar{a}), 
and additionally the expected value of the result index (\textit{i.e.}, \ttvar{n}).

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedDesc.png}
\end{center}
\caption{Synthesised Version of Vector Description}
\label{fig:synthversvecdesc}
\end{figure}

A simple example representing the vector \ttconstructor{[}\ttliteral{1}~\ttconstructor{,}~\ttliteral{2}~\ttconstructor{,}~\ttliteral{3}\ttconstructor{]} is presented in Figure~\ref{fig:exmvecsynthvecdesc}. Although the value might seem a bit overwhelming at first, it follows a simple pattern:
each time a value of \ttdec{Vec} is needed \ttconstructor{Con} is used, followed by its required arguments in the form of nested dependent pairs, and finally with \ttconstructor{Refl}, which ensures
that the provided index of the value matches up with the expected one.
There are 4 occurrences of \ttconstructor{Con} and \ttconstructor{Refl} in the example, three for  \ttconstructor{Cons} and one for \ttconstructor{Nil}.
For all cases the first two arguments represent the constructor label and associated tag. 
For \ttconstructor{Cons}, the first following argument is the length of the rest of the vector (the value of index \ttvar{n}) followed by the value of the list head and the list tail, ending with \ttconstructor{Refl}.
For \ttconstructor{Nil}, the value is ended with \ttconstructor{Refl} since it doesn't contain any data.


\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedExample.png}
\end{center}
\caption{Example vector representing \ttconstructor{[}\ttliteral{1}~\ttconstructor{,}~\ttliteral{2}~\ttconstructor{,}~\ttliteral{3}\ttconstructor{]} as a value of a synthesised description}
\label{fig:exmvecsynthvecdesc}
\end{figure}

As might have become apparent there are a couple of shortcomings in the example, or rather the way values of described types are constructed.
One shortcoming is that there is a lot of boilerplate required when values are constructed, which makes the result somewhat unreadable.
A solution to overcome that shortcoming is presented in the next paragraph. Another shortcoming is that the resulting terms become very large, and in turn slowing down program execution, compared to the original
version of the datatype. For example, \ttconstructor{Nil} becomes inflated to \ttconstructor{Con~(}\ttliteral{"Nil"}~\ttconstructor{** (TZ ** Refl))} which is significantly more complex. A description on how to improve the size of resulting terms and
speed up the performance of dependent programs is presented in Chapter~\ref{cha:OptimizingIdrisforFlight}.

In order to make creation of values of described types easier and the resulting terms more readable, it is possible to use functions as synonyms for the constructors.
Figure~\ref{fig:funcconstrsynthvec} shows \ttdec{Nil} and \ttdec{Cons} as synonyms for the described version of \ttconstructor{Nil} and \ttconstructor{Cons} respectively.
Since Idris can infer the values of \ttvar{a} and \ttvar{n} automatically in this context, they are converted to implicit arguments in these synonyms (which further increases readability).

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedConstructors.png}
\end{center}
\caption{Functions for constructing values of synthesised vector description}
\label{fig:funcconstrsynthvec}
\end{figure}

Using these synonyms, the constructor of the value in example in Figure~\ref{fig:exmvecsynthvecdesc} becomes simpler and much more readable. Figure~\ref{fig:exmvecsynthvecdescconstrs} shows the updated version,
and it looks almost exactly like the original value it needed to describe \ttconstructor{[}\ttliteral{1}~\ttconstructor{,}~\ttliteral{2}~\ttconstructor{,}~\ttliteral{3}\ttconstructor{]}.


\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedConstructorsExample.png}
\end{center}
\caption{More readable version of \ttconstructor{[}\ttliteral{1}~\ttconstructor{,}~\ttliteral{2}~\ttconstructor{,}~\ttliteral{3}\ttconstructor{]} using aliases from Figure~\ref{fig:funcconstrsynthvec}}
\label{fig:exmvecsynthvecdescconstrs}
\end{figure}

\section{The (mostly) gentle art of levitation}
\label{sec:TheMostlyGentleArtofLevitation}
The previous sections presented a series of constructions that makes it possible to have described types.
What may have become apparent for the reader is that many of these constructions such as \tttype{Data}, \tttype{Tag} and \ttdec{switch} cannot themselves be described,
since they are necessary building blocks for having descriptions.
However, what might be surprising is that the description type \tttype{Desc} itself, isn't in fact limited by such a constraint
and can be described using itself.
This is the key point addressed by \textcite{Chapman:2010:GAL:1863543.1863547} in \citetitle{Chapman:2010:GAL:1863543.1863547}.

The description datatype \tttype{Desc} contains many of the constructors needed to describe itself.
However, one might experience trouble when trying to describe \ttconstructor{Arg} since it requires an argument of the following type:
\texttt{(}\ttvar{a}~->\tttype{Desc}~\ttvar{ix}\texttt{)}.
This argument describes a function which result type is the datatype itself (a so-called higher-order inductive argument), which \ttconstructor{Rec} isn't strong enough to express since it only permits primitive recurrences.
Figure~\ref{fig:deschrec} shows a new constructor \ttconstructor{HRec}, which allows specification of such higher-order inductive arguments, it takes a type \ttvar{a} which specifies
the expected input type of such argument in addition to the rest of arguments that are expected by \ttconstructor{Rec}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ADescriptionForDatatypesExtended.png}
\end{center}
\caption{A constructor for \tttype{Desc} to represent higher-order recursion}
\label{fig:deschrec}
\end{figure}

The function \ttdec{Synthesise} must be extended with a clause for \ttconstructor{HRec}. Figure~\ref{fig:synthhrec} shows the corresponding clause,
which looks very similar to the one for \ttconstructor{Rec}, except the first component now requires a function from the provided type \ttvar{a} to the datatype itself instead of just a reference
to the datatype.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/SynthesisingDataExtended.png}
\end{center}
\caption{Synthesising \ttconstructor{HRec} to a real type}
\label{fig:synthhrec}
\end{figure}

Finally, all the required constructors are present and it is now possible to piece together a description for \tttype{Desc}. Figure~\ref{fig:descdesc} shows the complete description, including for the newly added
\ttconstructor{HRec} constructor. The description of \tttype{Desc} is parametrised by the type of indices \ttvar{ix} that possible derived descriptions can have, and is not indexed by anything particularly interesting (the unit type \tttype{()} is used in the figure).
The description for each constructor is translated using the same techniques presented in Section~\ref{sec:TheGenericStructureofInductiveDataTypes}. The only interesting case is the one for \ttconstructor{Arg}, which uses \ttconstructor{HRec ()}~\ttvar{a}~\texttt{(}\ttconstructor{Ret ()}\texttt{)} to represent the higher-order inductive argument \texttt{(}\ttvar{a}~->~\tttype{Desc}~\ttvar{ix}\texttt{)}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/DescriptionDescription.png}
\end{center}
\caption{Describing the \tttype{Desc} datatype itself}
\label{fig:descdesc}
\end{figure}

Perhaps, the key thing to notice is that a function \ttdec{switchDesc} was used instead of \ttdec{switch} when describing \tttype{Desc}.
Figure~\ref{fig:switchdesc} shows how \ttdec{switchDesc} is defined by specialising \ttdec{switch}. However, if \tttype{Desc} is a described type based on \ttdec{DescDesc} then such a definition would be circular.
This is because the general \ttdec{switch} requires the result type \tttype{Desc} to be given as an argument, but \tttype{Desc} is dependent on \ttdec{DescDesc}. Therefore, \textcite{Chapman:2010:GAL:1863543.1863547} define \ttdec{switchDesc} to be handled specially in their type theory, eliding the definition of the body
and hard-wiring its return type to be \tttype{Desc}
\footnote{Of course, such trick only works if the type \tttype{Desc} is already known to be in the meta-theory.
However, the knowledge of its elements is not necessarily required and it is possible to inspect these in a similar fashion to other datatypes.}.
Now, \ttdec{DescDesc} can be type checked without any issues and \textit{levitation} is achieved.

\begin{figure}[H]
\begin{center}
    \includegraphics[scale=0.5]{Figures/AConstructiveChoiceDesc.png}
\end{center}
\caption{A specialised version of \ttdec{switch} which returns descriptions}
\label{fig:switchdesc}
\end{figure}

\section{Ensuring tagging of descriptions}
\label{sec:Ensuring tagging of descriptions}
The plain description type \tttype{Desc} accepts descriptions of any form, something which can limit how some algorithms are written.
For example, it might be useful to pretty print the constructor tags differently from the constructor arguments, and therefore it would be nice if the type system ensured
that it was possible to know where the tags were.
Similarly, if one needs to extend the number of constructors in a described type, it is necessary to know how tags are used.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TaggingDescriptions.png}
\end{center}
\caption{A datatype for representing descriptions with tags}
\label{fig:tagdesc}
\end{figure}

\textcite{Dagand2013acosmology} suggests that it is possible to create a type representing tagged descriptions while keeping
the same level of expression (see Figure~\ref{fig:tagdesc} for an inspired implementation).
The type \ttdec{TaggedDesc} represents the type of functions from tags to descriptions, which is exactly the result type of function \ttdec{switchDesc}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/DetaggingDescriptions.png}
\end{center}
\caption{Converting tagged descriptions to ordinary descriptions}
\label{fig:untagdesc}
\end{figure}

A function \ttdec{Untag} which converts tagged descriptions to ordinary descriptions is displayed in Figure~\ref{fig:untagdesc}.
The \ttdec{Untag} function converts the function arguments of \tttype{TaggedDesc} to described data by using \ttconstructor{Arg}, which ensures
that the provided constructor tags are stored with their respective constructor arguments.

A key advantage of accepting a \ttdec{TaggedDesc} and then calling \ttdec{Untag}---instead of merely accepting an ordinary \tttype{Desc}---is that the type system
gains knowledge that the first two arguments of data are of type \ttdec{CLabel} and \tttype{Tag}.
This permits the algorithm designer, to treat those arguments differently when pretty printing the datatype, during serialisation, and so on and so forth.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TaggedDescriptionData.png}
\end{center}
\caption{The described version of tagged descriptions}
\label{fig:tagdata}
\end{figure}

Figure~\ref{fig:tagdata} shows a type \ttdec{TData} which is the analogous of \tttype{Data} for tagged descriptions.
The definition is simple as it simply converts the provided tagged description to an ordinary description, and then calls \tttype{Data} on that.
Therefore, the main point of using \ttdec{TData} is to make it easy to convert a tagged description to a described type.



\chapter{Partial evaluation}
\label{cha:PartialEvaluation}

The description datatype \tttype{Desc} presented in Chapter~\ref{cha:GenericProgramming} was very flexible and could express many common algebraic datatypes.
However as discussed in Section~\ref{sub:Example:Constructing Vectors}, the corresponding terms used to construct values of described types were much larger and more complex than the corresponding values of ordinary datatypes, yet they do not convey much more relevant information.
The reason is that much of the contained data is static information needed solely to provide the right form for generic algorithms, but is not needed when dealing with specific structures.
Therefore this chapter discusses relevant partial evaluation techniques needed to minimise the size of the large terms in order to improve runtime performance, by specialising the algorithm with regards to relevant static data when possible.

\section{The static nature of programs}
\label{sec:Thestaticnatureofprograms}
It hardly comes as a surprise, that for many programs, not all of their input might be dynamic.
Sometimes it is due to the way programs are structured in a modular fashion (e.g. functions or objects), where readability and reusability are highly valued even if some of the input to these structures is static.
For example, writing \ttdec{minutesInADay}~\texttt{=}~\ttliteral{24}~\texttt{*}~\ttliteral{60} is usually seen as more preferable to writing \ttdec{minutesInADay}~\texttt{=}~\ttliteral{1440}, since
it better captures the intent of the programmer.
Other times, it may be because that the input is known ahead of time and therefore in some way hard-coded (\textit{e.g.}, configuration files or constants).
No matter what reason, it can be said that any program \ttdec{p} accepts a series of static input \ttvar{i$_{s_0}$}\texttt{\ldots}\ttvar{i$_{s_n}$}~\texttt{$\in$}~\ttvar{I$_{s}$} and a series of dynamic input \ttvar{i$_{d_0}$}\texttt{\ldots}\ttvar{i$_{d_m}$}~\texttt{$\in$}~\ttvar{I$_{d}$}, resulting in some output \ttvar{O}.
%A program can be said to have both static and dynamic input

In many cases it is desirable to only compute programs with known input once and for all, instead of suffering a performance loss every time the program is run.
One technique for static computation of programs, is called \textit{partial evaluation}\,\autocite{Jones:1993:PEA:153676}. A program that does partial evaluation \ttdec{mix} is called a \textit{partial evaluator}, and accepts as input another program (often called the \textit{object program}) and a series of static input for that particular program.
The result of \ttdec{mix} is a new program called the \textit{residual program} which is \textit{specialised} with regards to the specified static input.
That is for any program \ttvar{p}, partially evaluating it regarding its static input \ttvar{I$_s$}---that is \ttdec{mix}~\ttvar{p}~\ttvar{I$_s$}---results in a residual program \ttvar{p$_r$}.
The residual program \ttvar{p$_r$} accepts the remaining dynamic input \ttvar{I$_d$} and produces the same expected result \ttvar{O}; therefore, the following equation is satisfied: \ttvar{p}~\ttvar{I$_s$}~\ttvar{I$_d$}~\texttt{$\equiv$}~\texttt{(}\ttdec{mix}~\ttvar{p}~\ttvar{I$_s$}\texttt{)}~\ttvar{I$_d$}~\texttt{$\equiv$}~\ttvar{p$_r$}~\ttvar{I$_d$}~\texttt{$\equiv$}~\ttvar{O}.

The canonical example of partial evaluation \autocite{Jones:1993:PEA:153676,mogensen1997,taha2004gentle} is the \ttdec{power} function which calculates $x^n$ and is displayed in Figure~\ref{fig:powexmp}.
In this version of \ttdec{power}, the control flow is mostly determined by its first variable \ttvar{n}.
Therefore, if \ttvar{n} is provided statically then it is possible to specialise \ttdec{power} to avoid the branching dependent on \ttvar{n} and recursion at run-time.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerExample.png}
\end{center}
\caption{The function \ttdec{power} which calculates the value $x^n$ for input integers $x$ and $n$}
\label{fig:powexmp}
\end{figure}

Figure~\ref{fig:powspec} shows a partially evaluated version of power, where \ttvar{n} is fixed statically to \ttliteral{5}.
To achieve such optimisation, the partial evaluator must support various interesting optimisation techniques such as \textit{constant folding}, \textit{program point specialisation} and \textit{unfolding}/\textit{transition compression} \autocite{Jones:1993:PEA:153676} which will be discussed further in Section~\ref{sec:Anoptimisingpartialevaluator}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerSpecialised.png}
\end{center}
\caption{\ttdec{power} specialised with regards to \ttvar{n} set to \ttliteral{5}}
\label{fig:powspec}
\end{figure}

\section{An optimising partial evaluator}
\label{sec:Anoptimisingpartialevaluator}
Since the only requirement for a partial evaluator is that the residual program depends only on some dynamic input, it is simple to make a trivial partial evaluator.
The trivial partial evaluator simply ``hard-codes'' the provided static input, and otherwise leaves the input object program unchanged.
However, such partial evaluator is hardly interesting from a performance perspective.
In order for a partial evaluator to be interesting, it must be able to utilise a set of optimisation techniques while evaluating a program.
In this section, three commonly used optimisation techniques for partial evaluators are presented: constant folding, program point specialisation and unfolding.

\subsection{Program Point Specialisation}
\label{sub:Program Point Specialisation}
According to \textcite{Jones:1993:PEA:153676}, a \textit{program point} is a referable point of execution that forms a part of a larger program.
For many modern languages, a program point would be a function or procedure; however, it could also be a label in an assembly language or a clause definition in a logic language.
Program point specialisation is the act of creating new versions of existing program points specialised with regards to some statically provided input.
That is, a specialised version of a program point \ttvar{l} is a pair \texttt{$\langle$}\ttvar{l}~\texttt{,}~\ttvar{I$_s$}\texttt{$\rangle$} such that \ttvar{I$_s$} is some provided
static input somewhere in the program.
Figure~\ref{fig:powxuf} shows a version of \ttdec{power} where \ttvar{n} is specialised to \ttliteral{5}, and all recursive calls to power are partially evaluated using program point specialisation.

\subsubsection{Polyvariant Specialisation}
\label{par:PolyvariantSpecialisation}
A program point specialisation is said to be \textit{polyvariant} if there are multiple versions of originally the same program point specialised with varying static input \autocite{Hughes:1999:LNCS:1706,Jones:1993:PEA:153676}.
For example, the \ttdec{power} function is specialised with regards to different values for the exponent \ttvar{n} in Figure~\ref{fig:powxuf} and is therefore polyvariant.

A special case of polyvariant specialisation, is when a program point specialisation is said to exhibit a \textit{polyvariant division}. A division is polyvariant if the set of static arguments varies for specialised versions of that particular program point.
Finding a division between static and dynamic arguments of a program point is not a trivial task, and especially not finding a polyvariant one.
Section~\ref{sec:Binding-timeAnalysisofPrograms} discusses what techniques there are for finding such divisions.


\subsection{Constant folding}
\label{sub:Constant folding}
Simply put, constant folding is the idea of reducing pure expressions with statically known arguments as much as possible.
This includes simple primitive arithmetic and logic operations such as addition, multiplication, conjunction and equality testing; but also pruning statically-determined branching such as \texttt{\textbf{if}}-expressions\,\autocite{Wegman:1991:CPC:103135.103136,Jones:1993:PEA:153676} or \texttt{\textbf{case}}-trees\,\autocite{boquist1999code}.

\paragraph{Reducing arithmetic and logical operations}
\label{par:Reducingarithmeticandlogicaloperations}
If all the operands of a given arithmetic or logical operator are statically determined then reducing such an operation is simply evaluating the result, \textit{e.g.}, for an expression \ttliteral{2}~\texttt{+}~\ttliteral{2} it can simply be reduced to the value \ttliteral{4}.
However, constant propagation algorithms are often allowed to do other types of simplifying reductions where some operands are dynamic, such as reducing addition with \ttliteral{0}, multiplication with \ttliteral{1} or conjunction with \ttconstructor{True}.

Figure~\ref{fig:powxcf} shows \ttdec{power} from Figure~\ref{fig:powexmp} again under specialisation with \ttvar{n} set to \ttliteral{5}. In the figure, all arithmetic expressions (namely \ttdec{mod}, \ttdec{div} and ``\texttt{-}'') and logic expressions (namely ``\texttt{==}'') have been reduced to simple integer values.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerExampleConstantFolding.png}
\end{center}
\caption{Reduction of arithmetic and logical expression in \ttdec{power} with \ttvar{n} set to \ttliteral{5}}
\label{fig:powxcf}
\end{figure}


\paragraph{Branch pruning}
\label{par:Branch pruning}
If a conditional is somehow reduced to a constant value by another optimisation, it is possible to completely eliminate branching in \texttt{\textbf{if}}- or \texttt{\textbf{case}}-expressions.
For \texttt{\textbf{if}}-expressions, if the conditional is reduced to \ttconstructor{True} then the whole expression is reduced to the \texttt{\textbf{then}} branch, otherwise (if it is reduced to \ttconstructor{False}) then the whole expression is reduced to the \texttt{\textbf{else}} branch.
For \texttt{\textbf{case}}-expressions, they are simply reduced to the branch that matches the pattern of the value provided.

Figure~\ref{fig:powxbp} shows an updated version of \ttdec{power\_n5} from Figure~\ref{fig:powxcf}.
Since all \texttt{\textbf{if}}-expressions depended on constant values, it was possible to completely eliminate branching from the result.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerExampleBranchPruning.png}
\end{center}
\caption{Pruning of statically determined branches for \ttdec{power\_n5}}
\label{fig:powxbp}
\end{figure}

Using more advanced optimisation techniques, it is still possible to reduce branches of \texttt{\textbf{case}}-expressions if only some parts of the conditional are statically determined. If the reader is interested, please refer to \textcite{PeytonJones:1992:IFL:129390} and \textcite{boquist1999code}.

\subsection{Unfolding}
\label{sub:Unfolding}
To avoid too many unnecessary indirections in specialised programs, a perhaps important technique is unfolding.
Unfolding is usually done at sites where there are function calls and corresponds to inlining the body of the function that is called at the place where it is called.
In addition to simply inlining the body of the function, unfolding usually needs to do renaming of local variables to avoid clashes with the external environment.
For a languages with labels, transition compression serves as a good analogue to unfolding, where a jump to a label is replaced with the following instructions.
While there are many advantages to unfolding, and likewise transition compression, if not careful the partial evaluator can end up in an infinite loop or the resulting code can end up with exponential size in the case of poorly chosen static variables\,\autocite{Jones:1993:PEA:153676}.
Therefore, unfolding cannot be seen as a generally safe technique and must be used with care in places where there are branching or similar.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerExampleBranchUnfolding1.png}
\end{center}
\caption{The function \ttdec{power\_n5} and necessary dependencies after program point optimisation
and constant folding}
\label{fig:powxuf}
\end{figure}

Figure~\ref{fig:powxuf} shows further transformation of the code in Figure~\ref{fig:powxbp}, after the completion of necessary program point specialisation and constant folding.
As can be observed in the figure, there is alot of indirection in each specialisation of \ttdec{power} requiring a new function call for all cases except when \ttvar{n} is set to \ttliteral{0}.
It is therefore desirable to do unfolding to improve performance, and doing unfolding for \ttdec{power\_n5} brings us back to Figure~\ref{fig:powspec} which is the final form of the optimisation.


\section{Dividing the static and dynamic parts of a program}
\label{sec:Binding-timeAnalysisofPrograms}
In Section~\ref{sec:Thestaticnatureofprograms}, an argument was made that programs usually contain both static and dynamic input.
A division for a program point is specifically an assignment of a binding-time, either static or dynamic, to each argument and expression at that point.
There are generally two non-exclusive ways to get the binding-time of variables, one is using a binding-time \textit{analysis}
and the other is requiring \textit{annotation} of binding-time by the user using \textit{e.g.}, \textit{two-level} syntax\,\autocite{Nielson:1989:TSA:75491.75492,Jones:1993:PEA:153676}.
In the broadest sense, binding-time analysis is vaguely similar to type inference while checking whether binding-time is well-annotated is vaguely similar to type checking.

\subsection{Binding-time analysis}
\label{sub:Binding-time analysis}
The core idea in a binding-time analysis (BTA) is to infer from given initial program input, what parts of a program may be executed statically.
For functional programming languages like Idris, there are roughly four classes of expressions which have different set of binding-time behaviour:
constants, variables, function application/operators, and conditionals/case analysis.
\begin{itemize}
  \item Constants are always assumed to be static, independent of whether they are for primitive types such as integers or strings, or base constructors of datatypes.
  \item The binding time for a variable usually depends on the type of variable and the surrounding environment.
    If the variable is let-bound or globally declared it will get the binding-time of the expression that is assigned to it.
    For function arguments they are assumed to be static in the function body, unless they appear dynamically in a recursive call.
    The partial evaluator can only optimise function calls when their arguments are known to be static, but such requirement is put where the function is called and not in the body of the function.
  \item The result of function and operator application is assumed to be static if all input arguments are static, otherwise it is dynamic.
   One must take special care of functions which perform environmental side-effects, such as those using the \tttype{IO}-monad in Idris, which result must always be classified as dynamic (since the result can't be determined at binding time).
  \item Conditionals expressions like \texttt{\textbf{if}} and \texttt{\textbf{case}} are considered to be static if the condition they depend upon is static (since that determines the control flow), otherwise dynamic.
\end{itemize}

When the BTA is complete, the partial evaluator can use such information to create a new residual program.
For each function call with static arguments, it can choose to reduce all dependent static control flow and expressions; thereby creating a new program that depends solely on dynamic input.


%\begin{mathpar}
  %\inferrule*[Left=Const]{  }{\Gamma \vdash c \Rightarrow S}
%\end{mathpar}

%\begin{mathpar}
  %\inferrule*[Left=Var]{x : \tau \in \Gamma}{\Gamma \vdash x \Rightarrow \tau}
%\end{mathpar}

%\begin{mathpar}
  %\inferrule*[Left=App]{\Gamma \vdash x_0 \Rightarrow \Gamma \vdash \tau_0\ldots x_{n-1} \Rightarrow \tau_n \\ \text{$f$ is a function with $n$ arguments}}
  %{\Gamma \vdash f x_0 \ldots x_{n-1} \Rightarrow \sqcup_{i = 0}^{n-1} \tau_i}
%\end{mathpar}

\subsection{Two-level syntax}
\label{sub:Two-levelsyntax}
Another approach to state binding-time of an expression is to allow the user to annotate programs using two-level syntax.
This approach is used in \textcite{Jones:1993:PEA:153676}, but is also available for popular programming languages such as OCaml\,\autocite{taha2004gentle} and Java\,\autocite{Westbrook:2010:MJM:1809028.1806642}.
The core idea behind two-level syntax is to provide static version of available expressions such as control structures, application and lambda abstractions in addition to the dynamic versions.
Two-level expressions that are static are often presented as underlined versions of their dynamic counterparts (\textit{e.g.}, \texttt{\textbf{\underline{if}}}), and usually an operator is used to distinguish between
static and dynamic application such as \texttt{\textbf{\underline{\$}}} or \texttt{\textbf{\underline{@}}}.
In order to allow embedding of static expressions inside dynamic values a built-in annotation \texttt{\textbf{lift}} is usually provided.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PowerAnnotated.png}
\end{center}
\caption{Two-level syntax annotated version of \ttdec{power} function, where underlined operations are static}
\label{fig:powan}
\end{figure}

Figure~\ref{fig:powan} shows an annotated version of \ttdec{power} where \ttvar{n} is assumed to be provided statically.
The annotation shows what will be reduced after a value for \ttvar{n} is provided, and as can be seen in the specialised version (see Figure~\ref{fig:powspec}) there
are no traces left of expression marked as static in the residual program.
If \ttvar{n} is to be provided at runtime, it is usually possible to forget the binding-time annotations and execute all of \ttdec{power} dynamically.


\section{Constructor specialisation}
\label{sec:ConstructorSpecialisation}
The previous sections focused mostly on partial evaluation as a way of optimising code, however \textcite{Mogensen:1993:CS:154630.154633} and \textcite{Dussart:1995:PCS:215465.215554} suggest that partial evaluation is also a useful technique to optimise data.
The core idea is to specialise constructors in the same vein as specialising functions, or rather specifically, create new constructors as alternatives of algebraic datatypes where the statically provided input is fixed (or perhaps completely erased).

\subsection{Example: Serialisation to S-expressions}
\label{sub:Example:SerialisationtoS-expressions}

Assume there is a program that serialises an association list to an S-expression and is specialised with regards to a specific schema where it is either the name and age of a person or the name of a department.
Figure~\ref{fig:conspec} shows how a reasonable result could look like after using ordinary partial evaluation techniques.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ConstructorSpecialisation.png}
\end{center}
\caption{A program for serialisation \ttdec{serialize}, specialised using classic techniques with regards to a specific schema}
\label{fig:conspec}
\end{figure}

There are however still some drawbacks with such program: it requires pattern matching on nested constructors, and does multiple string comparisons, both of which are potentially very time consuming.
Yet, much of the data is statically specified, so it seems that there is still room for improvement.
Luckily, constructor specialisation permits specialisation of data by creating suitable constructors in a suitable datatype.
Figure~\ref{fig:conspecdata} shows how new constructors are created in a datatype \tttype{Schema} such that all static data is eliminated, and two suitable constructors are created: \ttconstructor{Person} and \ttconstructor{Department}
\footnote{For ease of reading, the naming is prettified compared to what automated constructor specialisation would generate}.
After constructor specialisation, now the only comparison necessary is comparing tags of datatypes, something which should be much more efficient than the old solution.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ConstructorSpecialisationData.png}
\end{center}
\caption{A constructor specialised version of \ttdec{serialize}}
\label{fig:conspecdata}
\end{figure}

\subsection{Algorithm for specialising constructors}
\label{sub:Algorithm for specialising constructors}
\textcite{Dussart:1995:PCS:215465.215554} presents a step-by-step algorithm for performing constructor specialisation that has multiple advantages compared to the original one presented in \textcite{Mogensen:1993:CS:154630.154633}.
One advantage is that it specialises constructors in a polyvariant fashion, which means that specialisation of one datatype can create multiple new datatypes.
Another advantage is that it only requires one pass for calculating the fix-point calculations necessary in order to create new suitable types.
The algorithm consists of three phases: finding a minimal pattern that describes the occurrences of constructors with static values, generating the necessary code operating on such values
and finally creating suitable datatypes to hold the specialised constructors.

\paragraph{A grammar of datatypes}
\label{par:Findingaminimalgrammar}
The first phase of the algorithm is to find a possibly recursive pattern or \textit{grammar} that describes what particular sets of constructors occur in the same expression
at given program points. For the example presented in Figure~\ref{fig:conspec}, the final grammar would look like something displayed in Example~\ref{exmp:grammarspec} (in BNF style notation).

\setlength{\grammarparsep}{12pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em}
\begin{exmp}
  \begin{grammar}
    <string> ::= \ldots

    <schema> ::= [(''name'', <string>), (''age'', <string>)]
    \alt [(''department'', <string>)]
  \end{grammar}
  \label{exmp:grammarspec}
\end{exmp}

The grammar is extracted by analysing the code structure for where data is constructed and suitably combining such data, e.g. having alternatives in the grammar where there are \texttt{\textbf{case}}-expressions.
To avoid non-termination while partially evaluating, the analysis tries to generalise (that is specify as dynamic) places where there occur recursive references to the same datatype.
The effect of that is that non-terminals in the grammar might be defined recursively, which closely mimics the structure of inductive datatypes.
Following extraction of the grammar, fix-point computation techniques inspired by \textcite{Jones:1986:DFA:512644.512672} are used to find a minimal function graph that depends on such grammar.
%A bit vague

\paragraph{Code generation}
\label{par:Code generation}
The second phase uses the minimal function graph found in the first one to construct specialised versions of functions.
This happens by traversing the graph and specialising each function as normal, recursively rebuilding expressions from specialised versions.
\texttt{\textbf{case}}-expressions are handled specially during code generation in order to accommodate the specialised datatypes, and therefore they are restructured, adding new branches, such that they fit the extracted grammar.

\paragraph{Defining suitable types}
\label{par:Defining suitable types}
The final phase is to group the newly generated specialised constructors into suitable type definitions.
This is done in order for the residual program to be valid (type correct) and the compiler can perform other datatype optimisations.
The process prestented is simple: it starts with all constructors being in their own datatype, and merges datatype as necessary when a program dependens on values from either datatype.

\chapter{Levitating Idris}
\label{cha:LevitatingIdris}

\section{Creating descriptions from ordinary datatype declarations}
\label{sec:Creating descriptions from ordinary data declarations}
The description datatype \tttype{Desc} mentioned in Chapter~\ref{cha:GenericProgramming} provides the necessary plumbing to perform generic programming.
However, creating described types required a lot of heavy encoding; requiring labels, descriptions and aliases to be manually written out using the provided low-level constructs.
It would be better if the compiler could generate the necessary descriptions and aliases from ordinary datatype declarations since that would provide the powerful generic constructs without sacrificing the immediate readability of how the datatype is structured.
This section highlights my effort on extending the Idris language with constructs to make it simpler to work with described types.

\subsection{High-level overview}
\label{sub:High-level overview}
To make it easier to use described types in Idris, I have added three new language constructs: one annotation on datatypes \texttt{\textbf{\%described}} and two built-in operations \texttt{\textbf{labels\_for}} and \texttt{\textbf{desc\_for}}.
The \texttt{\textbf{\%described}} annotation has to appear prior to a datatype declaration (see Figure~\ref{fig:natdeclgen}), and specifies that the compiler should generate the relevant constructs for working with described types.
The constructs that are generated are similar in style to the ones presented in Sections~\ref{sub:ADescriptionforDatatypes}--\ref{sub:Example:Constructing Vectors}, and represent the constructor labels of type \tttype{CEnum} for the datatype, the description of type \ttdec{TaggedDesc} for the datatype, an alias for the described version of the datatype and relevant aliases for its constructors.

\begin{figure}
\begin{center}
    \includegraphics[scale=0.5]{Figures/NatDeclarationGen.png}
\end{center}
\caption{An annotation \texttt{\textbf{\%described}} for generating descriptions from declarations}
\label{fig:natdeclgen}
\end{figure}

The \texttt{\textbf{labels\_for}} operation provides the generated constructor labels for a particular datatype.
For example, to access the generated version of \ttdec{VecCtors} from Figure~\ref{fig:vectctors}, one must use \texttt{\textbf{labels\_for}}~\tttype{Vec}.
Similarly \texttt{\textbf{desc\_for}} is used to access the generated description for a datatype, \textit{e.g.}, \texttt{\textbf{desc\_for}}~\tttype{Vec} returns the equivalent value of \ttdec{VecDesc} from Figure~\ref{fig:vecdescim}.
The type and constructor aliases are chosen to match the signature and name of the datatype to be described, similarly to how it was done in Section~\ref{sub:Example:Constructing Vectors}.

\subsection{Algorithms for generation}
\label{sub:Algorithms for generation}
When a user asks the compiler to generate relevant functions for working with described types (using \texttt{\textbf{\%described}}), then the compiler generates four types of functions:
one representing the constructor \underline{labels} of the datatype, one representing the \underline{description} of the datatype, one representing a \underline{type alias} based on the description, and, for each constructor of the datatype, a function that constructs an \underline{isomorphic value} of the described type.
The following paragraphs describe informally how each of these types of functions are generated from the perspective of the compiler.
The main part of the Haskell function that generates these functions can be seen in Appendix~\ref{cha:Generation function}.\footnote{Due to time constraints, the current version of the function only supports datatypes without parameters and indices.}

\subsubsection{Generation of labels}
\label{ssub:Generation of labels}
The first part of what is generated is a value containing a list of all the constructor names of the target datatype.
Since all the constructor names are represented internally as strings by the compiler, this step simply involves creating a new clause of type \tttype{CEnum} and then assigning to it the Idris representation of a list where all the constructor names are converted to string literals.

\subsubsection{Generation of descriptions}
\label{ssub:Generation of descriptions}
The second part of what is generated is a value containing the description of the target described datatype.
Algorithm~\ref{alg:gendescd} works by traversing the Idris AST, finally producing a new declaration which contains the description.

\begin{alg}
  Generating descriptions for datatypes
  \begin{enumerate}
    \item Given a division of parameters \ttvar{x$_j$} and indices \ttvar{y$_k$} create a fitting type signature for the description
       \begin{enumerate}
         \item For parameters quantify those over the whole description value
         \item For indices, they are first ``uncurried'' in a dependent pair, and then the whole dependent pair is passed to the tagged description type \ttdec{TaggedDesc} as index
         \item[] That is, for a datatype
           
           \tttype{D}\texttt{:}\texttt{(}\ttvar{x$_1$}\texttt{:}\ttvar{a$_1$}\texttt{)}\texttt{\ldots}\texttt{(}\ttvar{x$_n$}\texttt{:}\ttvar{a$_n$}\texttt{)}\texttt{~->~}\texttt{(}\ttvar{y$_1$}\texttt{:}\ttvar{i$_1$}\texttt{)}\texttt{\ldots}\texttt{(}\ttvar{y$_n$}\texttt{:}\ttvar{i$_n$}\texttt{)}\texttt{~->~}\tttype{Type} the signature of the corresponding description becomes \texttt{(}\ttvar{x$_1$}\texttt{:}\ttvar{a$_1$}\texttt{)}\texttt{~->~}\texttt{\ldots}\texttt{~->~}\texttt{(}\ttvar{x$_n$}\texttt{:}\ttvar{a$_n$}\texttt{)}
           
           \texttt{->~}\ttdec{TaggedDesc}~\texttt{(\textbf{labels\_for}}~\tttype{D}\texttt{)}~\tttype{(}\ttvar{y$_1$}\texttt{:}\ttvar{i$_1$}\tttype{**}\texttt{\ldots}\tttype{**}\ttvar{y$_n$}\texttt{:}\ttvar{i$_n$}\tttype{)} where \ttvar{a$_j$} is the type of a parameter and \ttvar{i$_k$} is the type of an index
       \end{enumerate}
     \item Create a fitting clause for the description where all parameters \ttvar{x$_1$}\texttt{\ldots}\ttvar{x$_n$} are available as arguments
     \item To assign a value to the clause, calculate the value conforming to the $\pi$ type for the description and apply \ttdec{switchDesc} to the result
       \begin{enumerate}
         \item To calculate the value conforming to $\pi$ type for the datatype, iterate through the constructors such that for each constructor \ttvar{c$_j$}:
         \begin{enumerate}
           \item Create a new pair where the first component is the description for \ttvar{c$_j$} and the second component is the descriptions for the rest of the constructors ending with \ttconstructor{()}
           \item To calculate the description for \ttvar{c$_j$}, iterate through all its arguments:
           \begin{enumerate}
             \item If the argument is recursive, use the relevant constructor for recursion, either \ttconstructor{Rec} or \ttconstructor{HRec}, and apply it to the index values ``uncurried'' in a dependent pair
             \item[] For example, for an argument \tttype{D}~\ttvar{x$_1$}~\texttt{\ldots}~\ttvar{x$_n$}~\ttvar{y$_1$}~\texttt{\ldots}~\ttvar{y$_n$}\texttt{~->~\ldots} use \ttconstructor{Rec}~\ttconstructor{(}\ttvar{y$_1$}\ttconstructor{**}\texttt{\ldots}\ttconstructor{**}\ttvar{y$_n$}\ttconstructor{)}~\texttt{\ldots}
             \item Otherwise if the argument is not recursive, use \ttconstructor{Arg}
             \item[] For example, for an argument \texttt{(}\ttvar{x}\texttt{:}\tttype{A}\texttt{)}\texttt{~->~\ldots} use \ttconstructor{Arg}~\tttype{A}~\texttt{(\textbackslash}\ttvar{x}\texttt{=>\ldots)}
             \item Finally, when there are no arguments left use \ttconstructor{Ret} applying it to the expected indices similar how to it was done for recursive arguments
           \end{enumerate}
         \end{enumerate}
       \end{enumerate}
  \end{enumerate}
  \label{alg:gendescd}
\end{alg}

After the description is generated it is elaborated by the Idris compiler to ensure that the generated code is correct.
If the description is elaborated successfully, the user can then access it using the \texttt{\textbf{desc\_for}} operation as described in Section~\ref{sub:High-level overview}.

\subsubsection{Generation of aliases}
\label{ssub:Generation of aliases}
The generation of a type alias for a datatype \tttype{D} is simple.
First, create a new declaration with the same name \ttdec{D} and type signature of the datatype. 
Then, the result of \ttdec{D} is \ttdec{TData} applied to the description for that datatype \texttt{\textbf{desc\_for}}~\tttype{D}, with the parameters and indices adjusted to fit the expected form.
That is, the values of the parameters must be provided to the description to get a value of type \ttdec{TaggedDesc}~\texttt{(\textbf{labels\_for}}~\tttype{D}\texttt{)}~\tttype{(}\ttvar{y$_1$}\texttt{:}\ttvar{i$_1$}\tttype{**}\texttt{\ldots}\tttype{**}\ttvar{y$_n$}\texttt{:}\ttvar{i$_n$}\tttype{)}.
Then \ttdec{TData} is applied to that value in addition to the values of the indices which are packed together in a dependent pair yielding a value of type \tttype{Type} as required.

Generating constructor aliases requires a bit more effort than with type aliases, but still follows a step-by-step process.
The first thing to do is to enumerate all constructors, incrementally assigning each one a number (starting from \ttliteral{0}) which is used to calculate the corresponding \tttype{Tag} value.
Similarly to how type aliases were generated, a new declaration is then created for each constructor \ttconstructor{C} with the corresponding name \ttdec{C} and type signature.
The only difference is that recursive arguments in the type signature are changed to use the described version of the datatype using the generated type alias.
The result of \ttdec{D} is the application of \ttconstructor{Con} to an expression formed of right-nested dependent pairs that represent the synthesised version of the description for the datatype of \ttconstructor{C}.
That is, the nested dependent pairs contain the constructor label, followed by the constructor tag which is calculated from the assigned number, then followed by the arguments of the constructor
and finally ending with the value \ttconstructor{Refl}.

\section{Parametric extension to descriptions}
\label{sec:Parametricextensiontodescriptions}

While it was possible to describe parametrised datatypes using the description presented in Chapter~\ref{cha:GenericProgramming}, it was not possible to distinguish
between values of parameters and other kinds of values after instantiating the parameter.
Therefore, some of the algorithms which depend upon the knowledge of where a particular parameter is, such as the functorial map,
cannot be implemented in a generic fashion.
Since it would be desirable to implement such algorithms, a suitable description which has a built-in encoding of parameters must be created.
Section~\ref{sub:The parametricity of parameters} investigates some of the existing notions of what parameters are, and Section~\ref{sub:Parametrically extending the description} shows a new description which supports
the parametric notion of parameters.

\subsection{The parametricity of parameters}
\label{sub:The parametricity of parameters}
What is a parameter?
In an environment with dependent types, this simple question can lead to more answers than bargained for.
While almost all notions agree that the type \tttype{Vec}~\ttvar{a}~\ttvar{n} is parametrised by \ttvar{a} and indexed by \ttvar{n}, there has been seemingly less agreement on what a parameter is in general.
The issue is probably due to the different things that different kinds of parameters are used for, which overloads the word parameter.
I will in the following sections present some definitions of what a parameter actually is, explain the rationale behind each one and show where they don't agree.

\subsubsection{Parameters as eliminator quantifiers}
\label{ssub:Parameters as eliminator quantifiers}
One notion of a parameter is the one presented by \textcite{Dybjer97inductivefamilies}, and implemented in Idris\,\autocite{brady2013idris}.
The notion is defined in terms of how a parameter appears in the elimination rule for a particular datatype, where it is expected that parameters appear first in the type signature such that they are quantified over the complete elimination rule.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorElim.png}
\end{center}
\caption{Elimination rule for \tttype{Vec}}
\label{fig:vecelim}
\end{figure}

Since parameters are quantified over the elimination rule, it is ensured that they are constant relative to the property to be eliminated, \textit{i.e.}, they do not change depending on the value that may be provided as scrutinee.
Figure~\ref{fig:vecelim} shows the elimination rule for \tttype{Vec}, where it can be observed that \ttvar{a} is quantified over the whole expression and thus considered to be a parameter,
while \ttvar{n} changes in the property to be eliminated \ttvar{prop} and is therefore considered an index.

A restriction that is necessary to ensure that parameters are quantified correctly in the elimination rule, is that the parameter should appear uniformly in the result type and all of the recursive arguments of a constructor.
This rules out data structures such as the one presented in Figure~\ref{fig:nestedlist} to be considered having any parameters in this system, since the type argument \tttype{(}\ttvar{a}\tttype{,}\ttvar{a}\tttype{)} to the recursive argument of \ttconstructor{Cons} is different than the \ttvar{a} in the rest of the structure.

\subsubsection{Parameters as terms with parametricity}
\label{ssub:Parameters as terms with parametricity}
Another notion of a parameter which is presented by \textcite{bernardy2010parametricity}, is that it is a type argument which exhibits parametricity\,\autocite{DBLP:conf/ifip/Reynolds83,Wadler89theoremsfor}.
A type argument exhibits parametricity if the same relations in the datatype are satisfied independently of which value is provided; that is, one should not be able to inspect or constrain the value of a parameter (\textit{e.g.}, using propositional equality).
Figure~\ref{fig:nestedlist} shows a nested datatype\,\autocite{bird1998nested} \tttype{NList}, which is parametric even though \ttvar{a} does not appear uniformly in the datatype declaration.
The reason that \ttvar{a} is still considered parametric, is that the recursive argument uses \textit{functorial composition}.
With functorial composition, recursive arguments can use parameters in a non-uniform fashion as long as it does not change parametricity and preserves the expected relations.
In the \tttype{NList} example, the \tttype{NList}~\tttype{(}\ttvar{a}\tttype{,}\ttvar{a}\tttype{)} argument can be seen as a composition of \tttype{NList} with the homogenous pair type \texttt{\textbackslash}\ttvar{p}\texttt{=>}\tttype{(}\ttvar{p}\tttype{,}\ttvar{p}\tttype{)} which itself satisfies the necessary parametricity requirements.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/NestedList.png}
\end{center}
\caption{The nested datatype \tttype{NList}}
\label{fig:nestedlist}
\end{figure}

Parametricity of type arguments is necessary to correctly implement certain useful declarative functions, such as those that are methods of the \tttype{Functor}, \tttype{Traversable} and \tttype{Foldable} type classes from Haskell.
If constraints were made based on the type argument of the datatype, it wouldn't be possible to satisfy the associated laws of these type classes and possibly not even provide an implementation that can type check.

\subsubsection{Parameters as uniform indices}
\label{ssub:Parameters as uniform indices}
The last notion of a parameter is the one used in Agda\,\autocite{norell2009dependently} which only requires that parameters are uniform in the resulting type of constructors.
This allows the creation of more expressive datatypes, and can encompass both parametric parameters and parameters which are quantified uniformly over eliminators; however, it does not ensure either of these properties.
While this provides more freedom to decide how to structure datatypes, it makes it harder to see what correspondence there is between a parameter and the semantic properties it imposes.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorAlternativeDeclaration.png}
\end{center}
\caption{Alternative definition of \tttype{Vec} using equality constraints}
\label{fig:altvecdecl}
\end{figure}

For example, Figure~\ref{fig:altvecdecl} shows a datatype where both \ttvar{a} and \ttvar{n} are uniform in the result and which could accepted as a \citeauthor{norell2009dependently}-style parameter.
However, the arguments in this definition are neither parametric nor uniform and therefore do not fit into the other notions of parameters.


\subsection{Parametrically extending the description}
\label{sub:Parametrically extending the description}
One suggestion on how to ensure the parametricity of parameters was made by \textcite{bernardy2011theory}.
It was suggested that whenever a parameter was bound and parametricity was needed, one could provide an additional argument;
a \textit{witness} which proved that the parameter was parametric.
However such suggestion could be hard to work with in practical generic programming and instead this section will focus on providing
an encoding that is conservative in a way that disallows non-parametric use of parameters but is still able to express many interesting datatypes.

\subsubsection{Explicit parameters}
\label{ssub:Explicit parameters}

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ParDescriptionType.png}
\end{center}
\caption{A description for parametrised types}
\label{fig:pardesc}
\end{figure}

Figure~\ref{fig:pardesc} presents a description
\footnote{\ttconstructor{HRec} is omitted for presentation purposes, but can be added in the same style as presented in Chapter~\ref{cha:GenericProgramming}.}
akin to the one presented in Figure~\ref{fig:simpldescdatatype}
except a new constructor \ttconstructor{Par}---inspired by an encoding in \textcite{benke2003universes}---is added.
The constructor \ttconstructor{Par} represents an argument of the provided parameter in the datatype to be described.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ParSynthesising.png}
\end{center}
\caption{Synthesising an ordinary type from \tttype{ParDesc}}
\label{fig:parsynth}
\end{figure}

To convert the newly presented description to an ordinary datatype a suitable \ttdec{SynthesisePar} function is declared.
The function looks mostly the same as the one presented in Chapter~\ref{cha:GenericProgramming}, however the described type is now of type \tttype{Type}\texttt{ -> }\tttype{Type}
and there is an additional clause for \ttconstructor{Par}.
The clause for \ttconstructor{Par} produces a dependent pair similar to most other clauses, where the first component has to be an argument of the provided parameter as expected
and the second component is the type synthesised from the rest of the description.
Since it is not possible to depend on the type nor values of parameters in the presented encoding, parametricity is ensured by construction.
In return, some expression power is lost since it is not possible to have complex arguments that use these parameters.

\subsubsection{Supporting functorial composition}
\label{ssub:Supporting functorial composition}
In Section~\ref{sub:The parametricity of parameters} it was stated that parameters in nested datatypes were parametric because they were composed in a functorial fashion.
Therefore, it would be desirable to add such ability to the presented description datatype and thereby increase the expressiveness.

Figure~\ref{fig:pardescex} shows the addition of the constructor \ttconstructor{CompRec} which represents a nested recursive argument of a datatype.
The first argument of the constructor \ttvar{f} is the type to be functorially composed onto the parameter, and must therefore be a function that accepts the parameter
and returns a type.
To ensure that \ttvar{f} acts functorially, an additional argument \ttvar{ffunctor} must be given.
This variable \ttvar{ffunctor} provides the \tttype{Functor} type class instance for \ttvar{f}, and uses the built-in type resolution mechanism of Idris to automatically find that instance.
Finally the last argument is the rest of the description for the datatype to be described.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ParDescriptionTypeExtended.png}
\end{center}
\caption{Adding support for describing functorial composition}
\label{fig:pardescex}
\end{figure}

As an example of a description for a nested datatype, please take a look at Figure~\ref{fig:nlistdesc}.
The figure shows the description for \tttype{NList} from Figure~\ref{fig:nestedlist}, and the most interesting
part is the application of \ttconstructor{CompRec}.
In this context it is applied to a functor \ttdec{PairP}, which represents the same type as \texttt{\textbackslash}\ttvar{p}\texttt{=>}\tttype{(}\ttvar{p}\tttype{,}\ttvar{p}\tttype{)} from Section~\ref{sub:The parametricity of parameters}.
To type check this application of \ttconstructor{CompRec} there must be a \tttype{Functor} instance for \ttdec{PairP}, however it can be left out since Idris can resolve it implicitly.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/NestedListDescription}
\end{center}
\caption{Described version of \tttype{NList}}
\label{fig:nlistdesc}
\end{figure}

Converting \ttconstructor{CompRec} to an ordinary type is mostly similar to converting ordinary recursive arguments \ttconstructor{Rec} (see Figure~\ref{fig:parsynthex}).
The only difference is that \ttvar{f} must be applied to the parameter first before applying the described version of the type.
Here, it is perhaps clearest why such operation is called functorial composition, since \ttvar{x}~\texttt{(}\ttvar{f}~\ttvar{a}\texttt{)} is equivalent to \texttt{(}\ttvar{x}~\texttt{.}~\ttvar{f}\texttt{)}~\ttvar{a} which uses
the ordinary function composition operator ``\texttt{.}''.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ParSynthesisingExtended.png}
\end{center}
\caption{Transforming \ttconstructor{CompRec} to a type}
\label{fig:parsynthex}
\end{figure}


\subsubsection{Conversion to ordinary descriptions}
\label{ssub:Conversion to ordinary descriptions}

Descriptions for parametrised datatypes can be converted to ordinary description using a simple step-by-step process (see Figure~\ref{fig:pardesctodesc}).
The result type must be indexed by \tttype{Type}, because recursion expressed by \ttconstructor{CompRec} is not uniform and therefore can't be quantified uniformly over the whole description.
Since the converted description would hold the same data as the provided input description, it allows generic descriptions written for ordinary descriptions to be reused.
In fact, converting the description and then performing synthesis should yield isomorphic data, which means that \ttdec{Synthesise} only needs to be implemented for ordinary descriptions.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ParDescriptionConversion.png}
\end{center}
\caption{Converting \tttype{ParDesc} to ordinary indexed \tttype{Desc}}
\label{fig:pardesctodesc}
\end{figure}

While \tttype{ParDesc} and \tttype{Desc} were presented as two separate datatypes for readability purposes, they can be in fact combined.
The only thing that adds complexity is that the presence or absence of parameters must be accounted for at all stages, and further generalisation towards arity-generic programming requires some advanced fiddling with the type system.


\chapter{Practical examples}
\label{cha:PracticalExamples}

\section{Generic algorithms for deriving type class instances}
\label{sec:Genericalgorithmsforderivingtypeclassinstances}

\subsection{Specifying the necessary constraints}
\label{sub:Specifying the necessary constraints}

For many type classes, implementing them for a complex datatype sometimes requires an implementation of the type class for its parts.
For example, to pretty print a list of items it is required that there is a way to print each individual element.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ConstrainingTypeclasses.png}
\end{center}
\caption{A function that calculates type class constraints for a single parameter type class}
\label{fig:constrclass}
\end{figure}

Figure~\ref{fig:constrclass} shows a function \ttdec{Constraints1} that can be used to calculate type class constraints needed to have an instance of a type class \ttvar{class} (which takes a simple parameter of type \tttype{Type}) for a datatype \tttype{D}, given the description for \tttype{D}.
The function works by iterating over the description type and specifies that each external data member with description \ttconstructor{Arg}
must have an instance of the provided type class.
The only other interesting case is \ttconstructor{HRec}, where the false type \tttype{\_|\_} is required.
The false type makes it impossible to fulfil the constraints for a datatype using \ttconstructor{HRec}, and is used intentionally to avoid implementing algorithms using descriptions of that form.
This is because it is generally hard to implement arbitrary algorithms such as decidable equality on functions, of which \ttconstructor{HRec} is a representative.

\subsection{Pretty printing}
\label{sub:Pretty printing}
One of the most commonly used and automatically derived operations on datatypes is pretty printing.
Therefore, this function is suitable as an introductory example of a generic algorithm using our implementation of descriptions.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericShow.png}
\end{center}
\caption{Generically pretty printing a described type}
\label{fig:showgen}
\end{figure}

An algorithm for generic pretty printing \ttdec{gshow} is given in Figure~\ref{fig:showgen}, and clearly follows the informal algorithm presented in Example~\ref{exmp:prettyprint}.
The type signature of \ttdec{gshow} might look a bit daunting at first, but the only major difference from ordinary pretty printing is that it requires not just the data \ttvar{x} but also the associated description \ttvar{d}
and some constraints on its subcomponents \ttvar{constraints} to be able to pretty print them.
The function first prints the name of the input constructor, and then calls a function \ttdec{gshowd} which pretty prints the individual constructor arguments according to the provided description.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericShowDesc.png}
\end{center}
\caption{Iterating through the description and pretty printing individual components}
\label{fig:showgendesc}
\end{figure}

Function \ttdec{gshowd} in Figure~\ref{fig:showgendesc} iterates through the arguments of the input constructor.
If the end of the constructor (having description \ttconstructor{Ret}) is reached, the empty string is printed.
If it is a recursive argument, the generic show \ttdec{gshow} is called again with the description for the whole datatype, parenthesised if necessary; then the rest of the constructor arguments are printed.
Otherwise if it is an ordinary argument, the associated \ttdec{show} method is called using the instance provided from the constraints, again parenthesised if necessary, and then the rest of the constructor arguments are printed.
Finally, if a higher-order recursive argument is met it is dismissed using \ttdec{absurd} since it should not be possible to reach this case because the constraints require a value of type \tttype{\_|\_}.


\subsubsection{Example: Implementing \tttype{Show} for the described type \ttdec{Pair}}
\label{ssub:Example:ImplementingShowforPairs}
As an example of how to use the generic pretty print function \ttdec{gshow} to implement the \ttdec{show} method of \tttype{Show} type class for the described type \ttdec{Pair}, see Figure~\ref{fig:showinst}.
The call to \ttdec{gshow} is passed the description \ttdec{PairDesc} and the necesssary constraints \ttdec{pairShowConstrs} defined in Figure~\ref{fig:showconstrs}.
To create the constraints structure, one simply has to create a tuple to match the type required by \ttdec{Constraints1} and then call \ttliteral{\%instance} the right places.
The \ttliteral{\%instance} expression is evaluated at compile time, and allows Idris to perform type class resolution returning the associated instance for the target type class.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericShowInstance.png}
\end{center}
\caption{Creating a \tttype{Show} instance for \ttdec{Pair} using the generic \ttdec{gshow}}
\label{fig:showinst}
\end{figure}

The \tttype{Show} constraints for \ttdec{Pair} are easy to create, and are almost on the verge of being boilerplate.
In fact calculating the constraints for other single-parameter type classes have almost the exact same structure.
However, Idris cannot do type class resolution for any arbitrary type class \ttvar{c}, and therefore it is impossible to define a function that calculates these constraints (since it would not be able to type check).

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericShowConstraints.png}
\end{center}
\caption{Constraints necessary to implement \tttype{Show} for \ttdec{Pair}}
\label{fig:showconstrs}
\end{figure}

There could be two solutions to this problem: one would be to create a macro system for Idris which only type checks the expression after it is instantiated with the right type class, and another
would be to create a suitable tactic that calculates such constraints at compile time when needed.
Since these solutions would require considerable effort beyond the scope of this project, implementing any of them is considered to be future work.


\subsection{Decidable equality}
\label{sub:Decidable equality}
Something which is a bit more interesting to do generically is decidable equality, since that usually
requires handling a quadratic number of cases relative to the number of constructors, in addition to writing a significant number of associated lemmas.
However, before implementing decidable equality for described types, I will start by implementing it for \tttype{Tag} (recall from Figure~\ref{fig:ctortags}) to make it easier for the user to satisfy
the necessary constraints.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TagDecEqLemma1.png}
\end{center}
\caption{Lemma specifying that \ttconstructor{TZ} is not equal to \ttconstructor{TS}}
\label{fig:taglem1}
\end{figure}

To implement decidable equality for \tttype{Tag}, a couple of lemmas are necessary.
The first necessary lemma \ttdec{lemma\_tz\_not\_ts} is displayed in Figure~\ref{fig:taglem1} which shows that the different constructors of \tttype{Tag}, namely \ttconstructor{TZ} and \ttconstructor{TS} are different.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TagDecEqLemma2.png}
\end{center}
\caption{Lemma proving the injectivity of \ttconstructor{TS}}
\label{fig:taglem2}
\end{figure}

The second necessary lemma to prove is the injectivity of the constructor \ttconstructor{TS} (see Figure~\ref{fig:taglem2}).
That is, if given two values of constructor \ttconstructor{TS} which are equal, then it is possible to show that their inner arguments of type \tttype{Tag} are equal.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/TagDecEqLemmaInstance.png}
\end{center}
\caption{\tttype{DecEq} instance for \tttype{Tag}}
\label{fig:tagdeceqinst}
\end{figure}

Given the necessary lemmas, it should now be possible to implement the \tttype{DecEq} instance for \tttype{Tag}.
The cases are straightforward: if both constructors are \ttconstructor{TZ} then they are always equal, if they differ then they are not equal
and the \ttdec{lemma\_tz\_not\_ts} (or its symmetric version) is used as evidence, and finally if both constructors are \ttconstructor{TS} then they are equal
if their inner tags are equal, otherwise they are not and the injectivity lemma is used to compose the proof.

Now that there is a suitable implementation of decidable equality for the tags, it is possible to implement the generic version of decidable equality.
Similarly to the implementation for tags, a few injectivity lemmas are also needed for the generic version of decidable equality: 
one for the injectivity of \ttconstructor{Con}, and two for the injectivity of dependent pairs (which is the type that \ttdec{Synthesise} converts most descriptions to).

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqLemma1.png}
\end{center}
\caption{Lemma proving that \ttconstructor{Con} is injective}
\label{fig:dglem1}
\end{figure}

The injectivity lemma for \ttconstructor{Con} is displayed in Figure~\ref{fig:dglem1}.
It shows that given that two described types of type \tttype{Data} are equal, then the contained data must be equal too.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqLemma2.png}
\end{center}
\caption{Injectivity lemma for the first component of dependent pairs}
\label{fig:dglem2}
\end{figure}

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqLemma3.png}
\end{center}
\caption{Injectivity lemma for the second component of dependent pairs}
\label{fig:dglem3}
\end{figure}

The injectivity lemmas for dependent pairs are displayed in Figure~\ref{fig:dglem2} and Figure~\ref{fig:dglem3}.
The first lemma states that given that two dependent pairs are equal, then their first components are equal.
The second lemma states the same, but for the second components instead.

The implementation of generic decidable equality is displayed in Figure~\ref{fig:deceqgen}.
The type signature is a similar style to the one for generic pretty printing, and requires both the description
and necessary instances of decidable equality for the subcomponents of the datatype.
The implementation is defined such that two described types constructed with \ttconstructor{Con} are equal, if their individual data components (including constructor tag) are equal.
Otherwise if the individual data components are not equal, then the injectivity lemma for \ttconstructor{Con} is composed with the counter-proof to be used as a new counter-proof for inequality.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEq.png}
\end{center}
\caption{Generic implementation of decidable equality \tttype{DecEq}}
\label{fig:deceqgen}
\end{figure}

To check whether the individual components are equal or not, the function \ttdec{gdecEqd} is used, which takes as argument the original description and constraints (to use for recursive calls)
in addition to the description and constraints which need to be iterated.
The type signature for \ttdec{gdecEqd} is displayed in Figure~\ref{fig:deceqgendescty}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqDescType.png}
\end{center}
\caption{The type signature of \ttdec{gdecEqd}}
\label{fig:deceqgendescty}
\end{figure}

If the end of the description is reached (\textit{i.e.}, having the description \ttconstructor{Ret}), then two values are always considered to be equal.
The clause for \ttdec{gdecEqd} in the case of \ttconstructor{Ret} is displayed in Figure~\ref{fig:deceqgendesc1}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqDesc1.png}
\end{center}
\caption{Checking that two described types with description \ttconstructor{Ret} are equal}
\label{fig:deceqgendesc1}
\end{figure}

Probably the most interesting case is displayed in Figure~\ref{fig:deceqgendesc2} and is when it is an argument that is described (\textit{i.e.}, \ttconstructor{Arg}).
There are two things that needs to be checked, the equality of argument values themselves and the equality of the rest of the described type.
To check whether the values of the provided arguments are equal, \ttdec{decEq} is called with the provided type class instance from the constraints \ttvar{deceqa}.
If the values are equal then it is possible to proceed checking the rest of the described type, otherwise the \ttdec{lemma\_fst\_injective} lemma is used to compose a counter-proof.
If the rest of the described type is equal then an equality proof can be provided, otherwise the \ttdec{lemma\_snd\_injective} lemma is used to compose a counter-proof.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqDesc2.png}
\end{center}
\caption{Decidable equality for described types with description \ttconstructor{Arg}}
\label{fig:deceqgendesc2}
\end{figure}

The case of recursive arguments (\textit{i.e.}, \ttconstructor{Rec}) is similar to the case of ordinary arguments (see Figure~\ref{fig:deceqgendesc3}).
Since the equality of the recursive argument is independent of the equality of rest of the described type, both equalities can be checked at the same time.
To check the equality of the recursive arguments \ttdec{gdecEq} is called again with the description for the whole type and associated constraints, in addition to the values
of the recursive arguments.
If both the recursive arguments and the rest of the described type are equal than the result is that the data is equal,
otherwise a contraproof is composed using the necessary lemma.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqDesc3.png}
\end{center}
\caption{Decidable equality for described types with description \ttconstructor{Rec}}
\label{fig:deceqgendesc3}
\end{figure}

Finally, for described types with description \ttconstructor{HRec}, \ttdec{absurd} is used to dismiss the required implementation since the constraints are not satisfiable similar to
how it was dismissed for generic pretty printing (see Figure~\ref{fig:deceqgendesc4}).

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqDesc4.png}
\end{center}
\caption{Decidable equality for described types with description \ttconstructor{HRec}}
\label{fig:deceqgendesc4}
\end{figure}

Similarly to how a \tttype{Show} instance was implemented using \ttdec{gshow}, Figure~\ref{fig:deceqinst} shows how to implement a \tttype{DecEq} instance using
\ttdec{gdecEq}. The specific \tttype{DecEq} constraints \ttdec{pairDecEqConstrs} have exactly the same shape of definition as for \ttdec{pairShowConstrs} from Figure~\ref{fig:showconstrs}, the only difference
being that the type signature accepts \tttype{DecEq} instead of \tttype{Show}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericDecEqInstance.png}
\end{center}
\caption{Implementing the \tttype{DecEq} type class for \ttdec{Pair}}
\label{fig:deceqinst}
\end{figure}

\subsection{Functorial mapping}
\label{sub:Functorial mapping}
One interesting generic algorithm that wouldn't work on described types just using \tttype{Desc} is the generic map function, since it requires
an encoding of parameters.
Therefore, the algorithm is implemented using the version extended with parameters \tttype{ParDesc}.
The actual implementation of generic map \ttdec{gmapp} is displayed in Figure~\ref{fig:mapgen}, and simply says that
mapping a described type is simply the same as mapping its individual data components using \ttdec{gmappd}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericMap.png}
\end{center}
\caption{Generic map}
\label{fig:mapgen}
\end{figure}

The function used to map a function on the individual components \ttdec{gmappd} is presented in Figure~\ref{fig:mapgendesc}.
The implementation is straightforward and mostly iterates through the structure applying the generic mapping functions where possible, and the only two interesting cases are the ones for the value of the parameter type
and for the functorially composed recursion.
When a parameter value (described by \ttconstructor{Par}) is met, then the function to mapped \ttvar{f} is simply applied to that parameter and the mapping continues on the rest of the described type.
For the functorially composed recursive arguments (described by \ttconstructor{CompRec}), there are a couple of steps to be taken.
First, a mapping function \ttdec{map}~\texttt{@\{}\ttvar{mapc}\texttt{\}}~\ttvar{f} for the elements of the composed type is created by calling the associated \ttvar{Functor} instance \ttvar{mapc} for the composed functor \ttvar{g}, which then has the type \ttvar{g}~\ttvar{a}~\texttt{->}~\ttvar{g}~\ttvar{b}.
Thereafter, this mapping function has the right type to be provided to the recursive call of \ttdec{gmapp} and the recursive constructor argument can be mapped.
Finally, it is possible to map the rest of the described type.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericMapDesc.png}
\end{center}
\caption{Generically mapping the data components of a described type}
\label{fig:mapgendesc}
\end{figure}

The \tttype{Functor} instance for a type \ttdec{Nested}, that is described by \ttdec{NestedPD} from Figure~\ref{fig:nlistdesc}, is presented in Figure~\ref{fig:functorinst}.
The implementation simply passes the description \ttdec{NestedPD} to the generic map function \ttdec{gmapp}, which is enough since that implementation doesn't require any specific constraints.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericFunctorInstance.png}
\end{center}
\caption{Implementing the \tttype{Functor} type class for \ttdec{Nested}}
\label{fig:functorinst}
\end{figure}

\section{Algorithms with purely generic properties}
\label{sec:Algorithms with purely generic properties}
\subsection{Generic tag testing}
\label{sub:Generic tag testing}
One common pattern in the Idris standard library is to check whether a variable is of a particular constructor type, \textit{e.g.},
to get the \ttdec{head} of a list \ttvar{xs} then \ttdec{isCons}~\ttvar{xs} must be true and to convert a \tttype{Fin} to an integer using \ttdec{fromInteger} then \ttdec{isJust} is used to ensure that the conversion is safe.
Such patterns normally require setting up a new function for each particular constructor, however with the power of generic programming the pattern can be easily generalised into a function.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericIs.png}
\end{center}
\caption{Generic tag testing}
\label{fig:isgen}
\end{figure}

Figure~\ref{fig:isgen} shows a function \ttdec{is} which can be used for generic constructor testing.
The function uses the decidable equality on strings and values of type \tttype{Tag} to test whether a constructor the same tag to the one provided.
An interesting feature of \ttdec{is} is that it only requires the name of a constructor to be provided explicitly and will find the associated tag using proof search.
This is where the way \tttype{Tag} was structured really shines: Since the name of the constructor to be found and the list of possible constructors are part of the type signature
there is only one correct solution.
Therefore, the proof search will never produce the wrong result, since that would not be well-typed.

\subsection{Generic if expression}
\label{sub:Generic if expression}
Another interesting function that could be made generically is a generic version of the \texttt{\textbf{if}}-expression.
Normally the \texttt{\textbf{if}}-expression only works with conditions of type \tttype{Bool}, however the function \ttdec{gif} presented in Figure~\ref{fig:ifgen} works with any datatype with at least two constructors.
If the condition provided matches the first constructor of the datatype that had declared it, then the result is the false branch; otherwise the result of the function is the true branch.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericIf.png}
\end{center}
\caption{Generic \texttt{\textbf{if}}-expression}
\label{fig:ifgen}
\end{figure}



\section{Scrapping your dependently-typed boilerplate is hard}
\label{sec:Scrappingyourdependently-typedboilerplateishard}
%\textit{A version of the Uniplate library for Idris based on} \url{http://community.haskell.org/~ndm/uniplate/} \textit{and} \url{http://www-ps.informatik.uni-kiel.de/~sebf/projects/traversal.html} \textit{.
%This is useful for traversing structures in a generic fashion and especially when dealing with small changes in large data structures (such as compiler ADTs)}
The original purpose of this section was to present how I planned to implement a Uniplate-style\,\autocite{mitchell2007uniform} framework, as an example of how diverse the presented generic encoding is.
However, I found out while trying to implement the framework that there was no straightforward solution in a dependent types setting.
Instead, I will dedicate this section to presenting an informal explanation of the challenges that arise when trying to implement such framework.
Please note that the Uniplate-related figures presented in this section are translated from Haskell to Idris.

\subsection{Uniplate in 5 minutes}
\label{sub:Uniplate in 5 minutes}

The goal of Uniplate and other Scrap Your Boilerplate-style\,\autocite{lammel2003scrap} frameworks is to present practical operations that permit generic traversal of datatypes.
Specifically, these types of frameworks provide operations that are type directed, instead of focusing on particular data elements.
For example, a Uniplate operation could be to extract all expressions from some given input statement, compared to ordinary functions which would focus on working with particular elements of a statement such as the condition expression and two branches of an \texttt{\textbf{if}}-statement.
This allows many operations which often need to traverse deeply nested structures such as ASTs, to be succinctly written since only the necessary parts can be referred to.

While Uniplate provides a plethora of functions, there are two particularly interesting ones whose type signature is displayed in Figure~\ref{fig:uniplatefunc}.
The function \ttdec{universeBi} allows the extraction of all elements of a target type \ttvar{to}, from input data of the source type \ttvar{from}.
Complementarily, the function \ttdec{transformBi} allows lifting of a function that homogeneously maps elements of a target type \ttvar{to}, to a function that homogeneously maps elements of the source type \ttvar{from}.
The type signature of these functions require that there exists an instance of \tttype{Biplate} from the source type \tttype{from} to the target type \tttype{to}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateFunctions.png}
\end{center}
\caption{A couple of the most interesting functions for Uniplate}
\label{fig:uniplatefunc}
\end{figure}

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateClass.png}
\end{center}
\caption{The \tttype{Biplate} type class}
\label{fig:uniplateclass}
\end{figure}

The interface for the \tttype{Biplate} type class is presented in Figure~\ref{fig:uniplateclass}.
One constraint on the \tttype{Biplate} type class is that the target type \ttvar{to} must implement another type class \tttype{Uniplate}.
The type class \tttype{Uniplate} provides a function \ttdec{uniplate} which is similar to the \ttdec{biplate} function that is provided by \tttype{Biplate}
except the target datatype \ttvar{to} and the source datatype \ttvar{from} are restricted to be the same.
The signature of the \ttdec{biplate} function states that given input data of the source type \ttvar{from},
then it should be possible to extract a list of the elements of the target type \ttvar{to}, and given a list of new values with the same length it should be possible to create new data which conforms to the source type \ttvar{from}.
The whole interface provides a simple way to retrieve and create new elements for simple datatypes.

\subsubsection{Example: Modelling blog posts}
\label{ssub:Example: Modelling blog posts}
One place where something like Uniplate could be useful is when working with structured data models.
For example, Figure~\ref{fig:uniplateexmpdata} shows list of datatype declarations which represent a simplified model of blog posts.
In that model a blog post is either a single blog post with a title and a publication date, or a summarising blog post that aggregates a series of other posts.
Therefore in this model, blog posts form a tree-like structure.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateExampleData.png}
\end{center}
\caption{A simplified model over blog-posts}
\label{fig:uniplateexmpdata}
\end{figure}

Figure~\ref{fig:uniplateexmpops} shows a couple of interesting operations on the blog post model, which utilises the Uniplate functions from Figure~\ref{fig:uniplatefunc}.
The function \ttdec{timestamps} would extract all creation dates that exist in the input blog post using \ttdec{universeBi}, no matter how aggregated the blog posts are.
Similarly, the function \ttdec{capitaliseTitles} capitalises all the titles of the input blog posts, by applying \ttdec{transformBi} on a function \ttdec{capitalise} of type \tttype{Title}\texttt{~->~}\tttype{Title}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateExampleOperations.png}
\end{center}
\caption{Interesting operations using Uniplate on blog-post model}
\label{fig:uniplateexmpops}
\end{figure}

Usually, the \tttype{Biplate} type class can automatically be derived in Haskell if a datatype already supports the necessary generic encoding; that is, if it has instances for the \tttype{Typeable} and \tttype{Data} type classes, which can also be derived.
However, it is also possible to manually implement the necessary instances, and an example of an instance for \tttype{Biplate}~\tttype{Post}~\tttype{Timestamp} is displayed in Figure~\ref{fig:uniplatexmpinst}.
Since the \tttype{Post} datatype has two constructors, there are two cases to handle.
The case for the constructor \ttconstructor{Single} simply extracts the timestamp and returns it as a singleton list, and when to reconstruct the datatype the constructor \ttconstructor{Single} is used
on the same title as given originally and the newly provided timestamp.
Since \ttconstructor{Aggregate} doesn't contain any timestamps nothing is extracted, and when it is time to reconstruct the same element as the input is returned.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateInstance.png}
\end{center}
\caption{An instance of \tttype{Biplate} for working with timestamps in blog posts}
\label{fig:uniplatexmpinst}
\end{figure}



\subsection{Automatic deriving}
\label{sub:Automatic deriving}
As mentioned in Section~\ref{sub:Uniplate in 5 minutes}, one of the more useful features is the ability to automatically derive instances for the \tttype{Uniplate} and \tttype{Biplate} type classes.
However, as I will present in this section, such thing is not completely obvious how to do this correctly in a setting with dependent types.
In fact, the Uniplate documentation\,\autocite{mitchell2014uniplate} already warns that creating instances (even manually, not just by deriving) for polymorphic types could already produce
incorrect results:

\blockquote{
When defining polymorphic instances, be carefully to mention all potential children.
Consider \tttype{Biplate} \tttype{Int} \tttype{(Int,}~\ttvar{a}\tttype{)} - this instance cannot be correct because it will fail to return both \tttype{Int} values on \tttype{(Int, Int)}.
There are some legitimate polymorphic instances, such as \tttype{Biplate}~\ttvar{a}~\tttype{[}\ttvar{a}\tttype{]} and \tttype{Biplate}~\ttvar{a}~\ttvar{a}, but take care to avoid overlapping instances.}

\subsubsection{The type casing challenge}
\label{ssub:The type casing challenge}

The first challenge that arises when trying to generically derive instances, is that pattern matching on types is needed in order to identify which elements belong to the target type.
However, Idris does not permit pattern matching on types for two reasons: it would break parametricity and it would significantly hurt runtime performance.

Therefore, something like \tttype{Typeable} for Haskell is needed in order to recover type information at compile time.
Traditionally, the Universe pattern\,\autocite{altenkirch2007generic} is used in dependently typed languages as an analogue to provide an internal encoding of a limited set of types that can be matched on.
This is done by having a set of constructors called \textit{codes} in some type \tttype{U} to represent these types, and then an interpretation function \ttdec{El} which takes elements of \tttype{U} and translates them to actual types.
However, this can be problematic when types need to depend on values, since dependencies must be encoded as functions from interpreted codes to other codes.
Since it is not possible to pattern match the interpretation of codes which are actual types, it is not usually possible to recover the correct form of the type information at runtime.
In summary, the author has not been able to find a good encoding for an external way to do type casing for dependent types, and there are both proof theoretic and performance-related problems if such system is included in the core language.

\subsubsection{Distinguishing between the kind of data}
\label{ssub:Distinguishing between the kind of data}
Assuming it was possible to have a way to do something similar to type casing, there are still a challenge left regarding automatic deriving of
relevant Uniplate instances.
In dependently-typed programming languages, terms are not just used to contain data used at runtime, but sometimes they also contain data
that is needed at type level such as when indexing datatypes.
The challenge occurs when the two kinds of data intermix in datatypes when trying to derive the relevant \tttype{Biplate} and \tttype{Uniplate} instances.

For example, in the type \tttype{Vec}~\tttype{Nat}~\ttvar{n} there are natural numbers used both as elements and as indices of the datatype.
However, it is not generally possible to distinguish between the \tttype{Nat} element that is used as index and the \tttype{Nat} member elements, and when trying to extract all natural numbers in order to implement \tttype{Biplate}~\texttt{(}\tttype{Vec Nat}~\ttvar{n}\texttt{)}~\tttype{Nat} it is hard to only get the relevant member data.
Worse yet, it is not possible to reconstruct new data of type \tttype{Vec} if given an arbitrary \tttype{Nat} which should act as index, since that wouldn't necessarily fit the definition of the datatype.

One idea would be to try to completely avoid any data members which appear at type level, however such solution cannot be generally applied.
As an example see Figure~\ref{fig:olist} which presents a list which enforces a less-than ordering on the elements.
In such datatype, there is no difference between the data members and the members used as indices.
If the data members were omitted, then there is nothing interesting left to operate on.
In summary, it is hard to do automatic deriving for any arbitrary indexed datatype and therefore they must be created manually in applicable cases in order to have a correct implementation.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateOList.png}
\end{center}
\caption{A datatype describing a list with ordered elements}
\label{fig:olist}
\end{figure}

\subsection{Generic traversal}
\label{sub:Generictraversal}
Even if assuming that there somehow is a relevant \tttype{Biplate} instance for an indexed datatype, there would still be challenges with regards to generic querying and transformation.
If one examines the type signature of the generic traversal functions \ttdec{universeBi} and \ttdec{transformBi}, one can see that they force types to be monomorphic.
While there are many interesting operations that can be achieved on a non-indexed type like \tttype{List}~\tttype{Nat}, the available operations to be done on a monomorphic indexed type like \tttype{Vec}~\tttype{Nat}~\ttconstructor{Z} are far less interesting.

Therefore it is desirable that the generic traversal functions can have polymorphic indices which can change values such that they fit the relevant contained data.
Figure~\ref{fig:uniplatefuncimp} shows an updated version of these operations which allow individual elements to have different indices,
and transformations to change the indices.
The changes require a minor update to the \tttype{Biplate} interface such that the target type \ttvar{to} has type \ttvar{ix}~->~\tttype{Type} instead of just \tttype{Type}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateFunctionsImproved.png}
\end{center}
\caption{Updating Uniplate functions to allow changes in the index of the target type}
\label{fig:uniplatefuncimp}
\end{figure}

Given the update interface and a fitting implementation of \tttype{Biplate}, the \ttdec{universeBi} function should work adequately.
However, there is something not completely right about the \ttdec{transformBi} function; surely, it should not be possible to change arbitrary indices of a datatype?
Unfortunately no, if such a function was allowed the type system would be inconsistent since it would be possible to break datatype invariants.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateTransformCounterProof.png}
\end{center}
\caption{An example datatype that contains two vectors, where one has exactly one more element}
\label{fig:twovec}
\end{figure}

For example, Figure~\ref{fig:twovec} presents a datatype which contains two vectors and enforces the constraint that the second vector, must have exactly one element more than the first one.
Figure~\ref{fig:twovecfunc} presents a simple function that appends a given input vector to itself.
A problem occurs if a user tries to call \ttdec{transformBi}~\ttdec{double}~\ttvar{xs}, since such function would try to double the size of all vectors in the input data \ttvar{xs}.
The result would be that both vectors would have twice the length, thus making one of the vectors having two elements more than the other breaking the invariant of the datatype.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/UniplateTransformCounterProofFunc.png}
\end{center}
\caption{A function that appends a vector to itself}
\label{fig:twovecfunc}
\end{figure}

One suggestion to mitigate the problem would be to somehow separate actual data from constraints in the transformation, and then check that the resulting structure still conforms to the necessary invariants.
However, such a solution is hard to generalise into a proper type signature and also it might not be apparent how such constraints could be formed.
For example the \tttype{OList} displayed in Figure~\ref{fig:olist} seems in fact to be the best way to enforce an ordering on list elements.


\chapter{Optimising Idris for flight}
\label{cha:OptimizingIdrisforFlight}

The generic encoding of datatypes via descriptions provided a powerful and flexible way to implement algorithms once for many datatypes as displayed in Chapter~\ref{cha:PracticalExamples}.
This could save the programmer the time to these algorithms, while at the same time lessen the probability that a bug is made.

However, the flexibility of the presented encoding comes at a price: it adds a space overhead to the datatype which is linear to the size of the constructed data.
This can significantly hurt the runtime performance, and it is therefore desired to find a way to optimise the generated code such that the presented framework is a viable option to use for realistic programs.
Section~\ref{sec:Analysingtheencodingoverhead} presents an analysis on how the encoding adds overhead to the constructed data and which parts could be optimised away.
Section~\ref{sec:Preparingdescriptionsforerasure} presents an extension to the presented description type that enables erasure of arguments.
Finally, Section~\ref{sec:Sketchingoutanalgorithmforspecialisingdescribedtypes} presents an informal description of a partial evaluation-based algorithm that enables
specialisation of datatypes.

\section{Analysing the encoding overhead}
\label{sec:Analysingtheencodingoverhead}

To examine the overhead which incurs when constructing described types, the following paragraphs will present a few simple examples of constructed data from described types and analyse the individual components.

\subsection{The price of genericity}
\label{sub:The price of genericity}

\subsubsection{The case of informationless data}
\label{ssub:The case of informationless data}

In the presented description scheme, even simple datatypes become very complex when encoded as described types.
For example, Figure~\ref{fig:overheadbool} represents the described version of the boolean value \ttconstructor{True}.
It can be observed that there additional data is required to make it work in a described context.
The constructor \ttconstructor{Con} is required to build a described type, the label \ttliteral{"True"} and the dependent tag \ttconstructor{TS~TZ} are required to choose the type of data constructed, \ttconstructor{Refl} is used to enforce restrictions on indices
and all these arguments (of \ttconstructor{Con}) must be wrapped in several dependent pairs to store the data.
This is a stark contrast to simply using \ttconstructor{True}, which satisfies the required type by definition.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericsOverheadBool.png}
\end{center}
\caption{The described version of the constructor \ttconstructor{True} from \tttype{Bool}}
\label{fig:overheadbool}
\end{figure}

Another example representing the described version of the vector \ttconstructor{[}\ttliteral{42}\ttconstructor{]}, is presented in Figure~\ref{fig:overheadlist}.
The shape of the data is similar to the shape of the described version of \ttconstructor{True}, in that it uses \ttconstructor{Con} whenever data needs to be constructed, is immediately followed by the relevant constructor label and tag and always ends with \ttconstructor{Refl}
after containing the relevant constructor arguments.
Probably, the more interesting part is the constructor arguments to the described version of \ttconstructor{Cons} which are \ttliteral{0} and \ttliteral{42}.
Recall from Figure~\ref{fig:vecdescim}, that \ttliteral{0} represents the length of the recursive argument and \ttliteral{42} represents data of the parameter type.
Usually, the length of the recursive argument can be erased by Idris\,\autocite{tejiscak2014erasure}, since it can be inferred from the rest of the arguments.
If it was not erased the size of the list would be quadratic, since the natural numbers use a unary representation, and a natural number must appear at every application of \ttconstructor{Cons}.
However, the encoding presented does not make it possible to represent erasable arguments, and Section~\ref{sec:Preparingdescriptionsforerasure} discusses the changes that are necessary to achieve this feature.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericsOverheadList.png}
\end{center}
\caption{The described version of \ttconstructor{[}\ttliteral{42}\ttconstructor{]} of type \tttype{Vec}~\tttype{Nat}~\ttliteral{1}}
\label{fig:overheadlist}
\end{figure}

Since ordinary constructors and their described equivalents are isomorphic, the described versions do not strictly contain more information.
This is because much of the data of a described type is statically known and not in itself interesting.
The only thing that differs is the form, where the described versions are more suitable to be used with generic algorithms.
This difference however comes at a price: It requires storing additional data with increasingly more references, which could result in a significant performance loss at runtime.
It would therefore be desirable to use partial evaluation techniques when possible, to reduce the size of the datatypes at runtime, and improve the performance of dependent algorithms.

\subsubsection{It is all in the details}
\label{ssub:Itisallinthedetails}
The figures presented in the previous paragraphs do not provide a complete overview of what data there is, because implicit arguments were not displayed.
In fact, it can observed that things like parameter and index values are usually stored in these implicit arguments.

For example, Figure~\ref{fig:overheadboolimpl} takes a look again at the described version of \ttconstructor{True} (from Figure~\ref{fig:overheadbool}) but this time with the implicit arguments displayed.
The first thing to notice is that in addition to the other data, the type of indices, the index value and the description for the whole type must also be provided as arguments.
Additionally, the constructor tags also contain information about the current label, and the rest of the possible labels as implicit arguments.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericsOverheadBoolImpl.png}
\end{center}
\caption{The described version of \ttconstructor{True} with implicit arguments displayed}
\label{fig:overheadboolimpl}
\end{figure}

Similarly, Figure~\ref{fig:overheadlistimpl} shows the described version of \ttconstructor{[}\ttliteral{42}\ttconstructor{]} from Figure~\ref{fig:overheadlist} with implicit arguments described.
A thing to notice is that the type of indices and the description are provided as arguments for each application of \ttconstructor{Con}.
Looking at these examples, it would seem that the encoding might prove to carry a bigger overhead than initially assumed.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/GenericsOverheadListImpl.png}
\end{center}
\caption{The described version of \ttconstructor{[}\ttliteral{42}\ttconstructor{]} with implicit arguments displayed}
\label{fig:overheadlistimpl}
\end{figure}

Luckily, since many of these implicit arguments are inferable from the type signature, Idris can use various optimisation techniques like collapsing\,\autocite{Brady04inductivefamilies} and erasure\,\autocite{tejiscak2014erasure} so that they do not affect the runtime performance.
The data must however still be checked during elaboration, which makes elaborating data of described types significantly slower than equivalent constructors, since there are many more arguments that need to be inferred and checked.
Therefore, it is desirable to limit the amount of time used rechecking the same kind of structure.
One solution could be to provide aliasing functions\footnote{Unfortunately, at present Idris does not support pattern aliases so this would only work when constructing datatypes}
just as the ones presented in Chapter~\ref{cha:LevitatingIdris}, which could be used when working with specific described types.
Thus, for specific datatypes many arguments need only to be elaborated once for each alias, instead of every time new data is constructed.

\subsubsection{Annotating static data}
\label{ssub:Annotating static data}
There are several ways possible to analyse data in order to find the static parts.
For example, it could be possible to use the minimal function graph based analysis used in Section~\ref{sec:ConstructorSpecialisation}.
Yet, many of the described types can be generated from ordinary declarations as presented in Chapter~\ref{cha:LevitatingIdris}, and thus it may be known already at generation time what statics parts there are.
Therefore, it might be worthwhile as a heurestic to examine the generated constructor aliases, and try to identify what static data might be optimised already at those points.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedConstructorsAnalysis.png}
\end{center}
\caption{Annotating the static (underlined) and erasable (dotted underline) parts of the constructors for the described version of \tttype{Vec}}
\label{fig:btvecctors}
\end{figure}

Constructor aliases for the described version of \tttype{Vec} are displayed in Figure~\ref{fig:btvecctors}, along with annotations to show the static (solid underline) and erasable (dotted underline) parts
of the data. For \ttdec{Nil} all the provided data to \ttconstructor{Con} is static, which makes sense since \ttconstructor{Nil} is usually a nullary constructor and does not contain any data.
The only data that is not static for \ttdec{Cons} is \ttvar{n}, \ttvar{x} and \ttvar{xs}, which is equivalent to the data stored in the ordinary version of \ttconstructor{Cons}.
Since \ttvar{n} is inferable from the type signature of \ttdec{Cons}, it would usually be possible for Idris to erase such value.
In summary, there is plenty of room to specialise constructors to remove static and erasable parts of data already that already exist at the point where aliases are generated, and perhaps more so if a more elaborate analysis was performed.

\section{Preparing descriptions for erasure}
\label{sec:Preparingdescriptionsforerasure}
In Section~\ref{sec:Analysingtheencodingoverhead}, it was mentioned that it would be desirable if there was a way to synthesise types with erasable data from descriptions.
This Section presents a few extensions to the description type that enables the user to exploit erasability as an optimisation technique.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ErasureType.png}
\end{center}
\caption{An annotation to specify erasure of arguments}
\label{fig:erasety}
\end{figure}

Figure~\ref{fig:erasety} presents a simple type \tttype{Erasure} which can be used to specify the erasability of arguments.
The constructor \ttconstructor{None} specifies that no erasure should happen, and the constructor \ttconstructor{Erasable} specifies that an argument may be erased.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/DescriptionWithErasure.png}
\end{center}
\caption{Extending the description constructor \ttconstructor{Arg} to support an erasure annotation as argument}
\label{fig:erasedesc}
\end{figure}

To enable described types to have erasable arguments, the description must be slightly modified.
Figure~\ref{fig:erasedesc} shows an updated version of \ttconstructor{Arg}, which has an added first argument requiring an annotation of type \tttype{Erasure}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/ExistsType.png}
\end{center}
\caption{A dependent pair type \tttype{Exists}, with the first component being erasable}
\label{fig:existsty}
\end{figure}

The next step is to convert described types with description \ttconstructor{Arg} to ordinary types that satisfy the required properties of the given erasure annotation.
The target type to convert described types with erased arguments to is going to be \tttype{Exists} and is presented in Figure~\ref{fig:existsty}.
The type \tttype{Exists} is similar to the ordinary dependent pair, except the first argument of its constructor \ttconstructor{Evidence} is marked to be erasable (by using \texttt{.} in front of the argument)

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/SynthesisingDataWithErasure.png}
\end{center}
\caption{Synthesising the different versions of \ttconstructor{Arg}, depending on erasure properties}
\label{fig:erasesynth}
\end{figure}

The actual translation of the different kinds of \ttconstructor{Arg} values to types using \ttdec{Synthesised} is displayed in Figure~\ref{fig:erasesynth}.
The translation of non-erasable arguments is the same as before, but values having the \ttconstructor{Erasable} annotation are translated to \tttype{Exists} instead to ensure the correct erasure.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/VectorSynthesisedConstructorsWithErasure.png}
\end{center}
\caption{Updated version of alias \ttdec{Cons}, now using \ttconstructor{Evidence} for storing erasable argument \ttvar{n}}
\label{fig:erasecons}
\end{figure}

Finally, Figure~\ref{fig:erasecons} shows an updated version of \ttdec{Cons} where the value \ttvar{n} can be erased.
Notice however, that the resulting value must use \ttconstructor{Evidence} instead of the ordinary dependent pair constructor when constructing erasable arguments.

\section{Sketching out an algorithm for specialising described types}
\label{sec:Sketchingoutanalgorithmforspecialisingdescribedtypes}
This section will sketch out an algorithm for removing some of the static data identified in Section~\ref{sec:Analysingtheencodingoverhead},
by utilising the techniques presented in Chapter~\ref{cha:PartialEvaluation}.
The core idea of the algorithm is to exploit the additional information provided by the powerful dependent type system of Idris,
to eliminate some of the static overhead present in some datatypes.
While this algorithm seems to be usable in the case of specialising described types, it is not limited to that application and could probably be used for other kinds of datatypes, \textit{e.g.},
one could imagine specialising \tttype{Fin}~\ttliteral{2} to \tttype{Bool}.

\subsection{Specialisation of static parameters}
\label{sub:Specialisationofstaticparameters}
The first step towards specialising datatypes, is to specialise parameters when they are provided statically.
This is done by creating a new datatype declaration with almost identical definition, except that the parameters are fixed to the provided values
and any recursive argument refers to the newly specialised datatype.

There a couple of reasons why it is desirable to specialise parameters but not indices.
The first reason is that different branches could have different index values---like \ttconstructor{Nil} and \ttconstructor{Cons} of \tttype{Vec}---but it would still be desirable to keep both branches as part of the same type family.
The other reason is that since indices may change, the specialisation process may not terminate.
For example, specialising the \tttype{Nat} index \ttvar{n} for any instance of the type family \tttype{Vec} requires creating an unbounded amount of datatypes (\tttype{Vec}~\ttvar{a}~\ttliteral{0}, \tttype{Vec}~\ttvar{a}~\ttliteral{1}, \tttype{Vec}~\ttvar{a}~\ttliteral{2}, etc.).

Figure~\ref{fig:pesp} shows an example where \tttype{Data} (from Figure~\ref{fig:datafromdesc}) is specialised with the type of indices \ttvar{ix} set to \tttype{Nat},
and the description \ttvar{d} set to \ttdec{VecD}~\tttype{Int}.
Notice that the \ttdec{Synthesise} argument of \ttvar{Con} previously accepted a recursive reference \tttype{Data}~\texttt{(}\ttdec{VecD}~\tttype{Int}\texttt{)} as argument,
which must be changed to refer to the specialised version \tttype{Data\_\_Vec\_Int}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PESpecialising.png}
\end{center}
\caption{Specialising \tttype{Data} with parameter \ttvar{ix} having value \tttype{Nat}, and parameter \ttvar{d} having value \ttdec{VecD}~\tttype{Int}}
\label{fig:pesp}
\end{figure}

Since some arguments of \ttdec{Synthesise} in the constructor \ttconstructor{Con} are provided statically now, it is possible to normalise the expression.
Figure~\ref{fig:pespext} shows the normalised version of \ttdec{Synthesise} with regards to the provided arguments.
Notice that it is not possible to further normalise the \ttdec{Synthesise} application on \ttdec{switchDesc}, since \ttdec{switchDesc} is dependent on dynamic arguments \ttvar{l} and \ttvar{t}.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PESpecialisingExpansion.png}
\end{center}
\caption{Normalising the \ttdec{Synthesise} call from Figure~\ref{fig:pesp}}
\label{fig:pespext}
\end{figure}

\subsection{Unboxing nested references}
\label{sub:Unboxingnestedreferences}
Taking a value of a dependent pair type as argument may be less optimal than simply accepting the arguments directly,
since it requires an additional allocation or \textit{box} in memory.
This doesn't only increase the space requirements, but may also hurt runtime performance since it would require chasing multiple pointers each time the data needs to be accessed.

One particular technique used to avoid such situation is called \textit{unboxing}\,\autocite{Jones91unboxedvalues,Leroy97theeffectiveness}, which is used to inline references to other datatypes.
To unbox a datatype, one takes each reference to it and replace it by its individual components.
For example, to unbox a dependent pair \tttype{(}\ttvar{x}\texttt{:}\ttvar{a}~\tttype{**}~\ttvar{b}\tttype{)}, one takes the arguments of its constructor---of types \ttvar{a} and \ttvar{b a} respectively---
and uses these as arguments in the enclosing constructor.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PEUnboxing.png}
\end{center}
\caption{Unboxing the dependent pair type argument to ordinary arguments of \ttconstructor{Con}}
\label{fig:peunbox}
\end{figure}

Figure~\ref{fig:peunbox} shows the unboxing of the nested dependent pair in the constructor \ttconstructor{Con}.
The resulting arguments are the label \ttvar{l}, the tag \ttvar{t} and the rest of the description \ttvar{arg}.

\subsection{Trickery applies here}
\label{sub:Trickery applies here}
It would seem that after the Section~\ref{sub:Unboxingnestedreferences}, that all apparent static data has been eliminated and that we are seemingly stuck in doing further partial evaluation.
However, save some inlining of data not much has been achieved.
As observed in Section~\ref{sec:Analysingtheencodingoverhead} there is yet still some data which appears to be static after \ttvar{l} and \ttvar{t} is provided.

\textcite{Jones:1993:PEA:153676} suggests using a technique called \textit{the trick} where dynamically provided data can allow further partial evaluation if it is finitely enumerable.
This is done by creating a new branch for each possible value of the enumerable data, and then further partially evaluating each new branch.
Then a mechanism is used to select the correct branch dependent on the value of the enumerable data at runtime.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PETrick.png}
\end{center}
\caption{Splitting constructors based on the different possible values of \tttype{Tag} (with additional unboxing)}
\label{fig:petr}
\end{figure}

For the presented example in Figure~\ref{fig:peunbox}, the list of possible constructors  \ttconstructor{[}\ttliteral{"Nil"}\ttconstructor{,}\ttliteral{"Cons"}\ttconstructor{]} is known and so the value \ttvar{t} is finitely enumerable and by dependency the value \ttvar{l} becomes static.
The specialised version using the trick on \ttvar{t}, is presented in Figure~\ref{fig:petr} which has two new constructors representing the branches for the two valid values of \ttvar{t}, namely \ttconstructor{TZ} and \ttconstructor{TS TZ}.

The values displayed between angle quotes are the static data specialised with their correspondingly assigned values.
These values are not stored at runtime, but may be used by the compiler when specialising algorithms to substitute if these algorithms are dependent on these values.
For example, the generic pretty printing algorithm depends on knowing the labels and thus requires substituting either \ttliteral{"Nil"} or \ttliteral{"Cons"} where \ttvar{l} is used.

\subsection{Index substitution}
\label{sub:Index substitution}
The final optimisation step that can be performed on our example, is to convert simple obvious restrictions on parameters given by propositional equality to ordinary indices.
Figure~\ref{fig:pesubst} shows such optimisation where the parameter \ttvar{i} has been specialised to the restricted value in each branch---\ttconstructor{Z} for \ttconstructor{Con\_Nil} and \ttconstructor{S}~\ttvar{n} for \ttconstructor{Con\_Cons}---and the corresponding equality arguments has been removed.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PESubst.png}
\end{center}
\caption{Eliminating equality restrictions on type arguments, by inlining the expected values as indices}
\label{fig:pesubst}
\end{figure}


\subsection{Expansion in functions}
\label{sub:Expansion in functions}
Similarly to the other data-oriented specialisation algorithms presented in Chapter~\ref{cha:PartialEvaluation}, dependent functions must also be specialised to support the updated structure.
This includes creating new case trees when pattern matching or constructing objects of the specialised type, and then adjusting the control flow to match the new branches.

As an example of how to specialise functions to support the specialised datatypes, see Figure~\ref{fig:genericshow1}.
The figure presents a specialised version of \ttdec{gshow} with regards to the description \ttdec{VecD}~\tttype{Int} and the relevant constraints.
Please notice, that the specialisation could not further reduce the \ttvar{d} and \ttvar{cstrs} arguments which represent the description and constraints for constructor arguments,
since these are dependent on the \ttvar{label} and \ttvar{tag} variables which are bound dynamically.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PEGenericShow1.png}
\end{center}
\caption{Specialising \ttdec{gshow} with regards to the description \ttdec{VecD}~\tttype{Int} and its related constraints}
\label{fig:genericshow1}
\end{figure}

In order to be able to use the specialised datatype in \ttdec{gshow}, new branches has to be created which mirrors the branching done using ``the trick'' on the specialised datatypes.
Figure~\ref{fig:genericshow2} shows the specialisation of \ttdec{gshow} from Figure~\ref{fig:genericshow1}, where new branches has been created by enumerating possible values of \ttvar{tag} (\ttconstructor{TZ} and \ttconstructor{TS TZ}), similarly to when specialising \tttype{Data\_\_Vec\_Int}.
In the figure, two minor non-essential adjustments have been done. 
The first is that it is assumed that \ttdec{gshow} has been updated such that erasable arguments are not pretty printed, and thus neither is the argument \ttvar{n}.
The other adjustment is that after specialising the expression to print the arguments, it gets the form \ttdec{show}~\texttt{@\{}\ttliteral{\%instance}\texttt{\}}~\ttvar{x}, which has been reduced to simply \ttdec{show}~\ttvar{x} since they are equivalent.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PEGenericShow2.png}
\end{center}
\caption{The specialised version of \ttdec{gshow} after branching on \ttvar{tag} and further applying partial evaluation techniques}
\label{fig:genericshow2}
\end{figure}

Since the function argument now has right shape, it is now possible to replace the generic datatype argument with the specialised one.
Figure~\ref{fig:genericshow3} shows an updated version of Figure~\ref{fig:genericshow2}, where the different branches now uses the specialised constructors \ttconstructor{Con\_Nil} and \ttconstructor{Con\_Cons} and the concatenation expression has been slightly simplified.
Finally, it can be observed that the finished result looks very similar to how a manually-written \tttype{Show} instance for \tttype{Vec}~\tttype{Int} would have looked like, and therefore a similar performance characteristic is expected.

\begin{figure}[ht]
\begin{center}
    \includegraphics[scale=0.5]{Figures/PEGenericShow3.png}
\end{center}
\caption{The final specialised version of \ttdec{gshow}, using the specialised version of the datatype \tttype{Data\_\_Vec\_Int}}
\label{fig:genericshow3}
\end{figure}


\chapter{Discussion}
\label{cha:Discussion}

\section{Related Work}
\label{sec:Related Work}
\subsection{Less is more}
\label{sub:Less is more}
During the finishing stages of this project I had discovered a Ph.D. dissertation with some considerable overlap on subject, namely \citetitle{magalhaes2012less} by \cite{magalhaes2012less} at Universiteit Utrecht.
The main subject of the dissertation was to investigate relevant ways to generically model datatypes in context of Haskell programming, and how to optimise dependent functions to achieve good performance.

The theoretical part of the dissertation presented 5 different frameworks to model datatypes generically both in Agda and in Haskell---ranging from supporting simple datatypes to datatypes with indices and nested parameters---and provided a way to map between these models.
In contrast, I have chosen to rely on existing frameworks performing only some slight modifications, and instead focusing on providing a well-written tutorial to understand those.
As a part of the analysis, \citeauthor{magalhaes2012less} chose to look at the frameworks from the point of functoriality, and showed how it was possible to implement \tttype{Functor} in each of those models.
In my work, I had also provided a way to implement \tttype{Functor} on a description that supported nested datatypes, and which was correctly parametric by construction.
In addition, I had provided an analysis on what types of parameters there are in an environment with dependent types.

Similarly to the work presented in this project, \citeauthor{magalhaes2012less} had presented a way to get the generic version of a datatype from ordinary declarations.
That part however focused mainly on converting ordinary Haskell datatypes to the encoding presented in the framework, while this project focused on converting possibly dependent Idris datatypes to descriptions.
Since Haskell doesn't have dependent types, the encoding presented requires multiple datatypes to be combined and as such is different from the presented description datatype.

The work by \citeauthor{magalhaes2012less} also includes a wide variety of generic implementation of useful algorithms using Haskells type class mechanism, including the generic version of \tttype{Show}.
The generic show in this project is similar, however it uses an ordinary function on the description (requiring only type class instances for the datatype parts).
An implementation of generic decidable equality was presented on an Agda model of generic datatypes by \citeauthor{magalhaes2012less}, however the presented algorithm was showed semi-decidable equality.
That is, it used a \tttype{Maybe}-like type, only providing a proof if they were equal and otherwise providing a \ttconstructor{Nothing} value.
In this project, I have provided a more powerful generic implementation of decidable equality where either a proof was provided or a contra-proof was provided.
This requires handling a quadratic number of cases instead of linear, in addition to needing to set up various lemmas, since datatypes can be non-equal in various ways.
Finally, I had also presented a couple of purely generic algorithms which are not trivial to implement outside a powerful type system with tactic support like Idris.

Regarding optimisation, \citeauthor{magalhaes2012less} had designed, implemented and evaluated an algorithm for optimising generic operations used for deriving type classes for Haskell datatypes.
The algorithm requires an isomorphism between a datatype declaration and its equivalent generic representation, and uses techniques dependent on the isomorphism such as inlining, free theorem substitution and advanced case elimination to achieve excellent performance metrics.
The work presented in this report focuses on using another optimisation technique, namely partial evaluation and specifically constructor specialisation to optimise described types.
While there was only the design of an algorithm was presented in this report, the presented algorithm has a few advantages when working with more complex described types than the ones presented by \citeauthor{magalhaes2012less}.
One advantage is that the algorithm is not dependent on whether the described type was generated from a datatype declaration, or was manually created by the programmer, since the algorithm does not require an isomorphism to an ordinary datatype to exist.
Furthermore, the algorithm can specialise any kind of datatype with static parameters and is not limited to a particular encoding.
Another advantage is that the algorithm would also work with described types which are based on transformed descriptions, such as based on the free monad description transformation presented in \textcite{Chapman:2010:GAL:1863543.1863547} or the ornamenting structures presented in \textcite{mcbride2010ornamental} and \textcite{dagand2012transporting}.
Since the transformation of descriptions is often done using calculations on existing datatypes, it can be cumbersome to require the programmer to provide declarations for each possible instantiation in order to get good performance metrics.

\subsection{Everywhere in dependent types}
\label{sub:Everywhere in dependent types}
Section~\ref{sec:Scrappingyourdependently-typedboilerplateishard} discussed the challenges of implementing a SYB-style library in a language with dependent types that could preserve expected invariants of a datatype.
However, in a closed type system with type casing support, it would be possible to implement a generic traversal function that alters the result type dependent on the provided transformation as demonstrated by \textcite{diehl2013every}.
While this provides a simple way to perform many powerful transformations, it also comes at a price.
The function is not implemented to support descriptions, it breaks parametricity, and the output type might not be immediately what is expected.

%\section{Proposed Improvements}
%\label{sec:ProposedImprovements}

%\subsection{Any practical type theory permits forgetting unused dependencies}
%\label{sub:Any practical type theory permits forgetting unused dependencies}

%\subsection{An annotation system for functional generic programming}
%\label{sub:An annotation system for functional generic programming}



\section{Reflections and Outlook}
\label{sec:ReflectionsandOutlook}

\subsection{Usability from the perspective of ordinary programmers}
\label{sub:Usabilityfromtheperspectiveofordinaryprogrammers}
Generic programming using described types is a powerful concept, permitting programmers to write complex programs that works for many datatypes in a succinct fashion.
Naturally, it would be desirable to enable ordinary programmers to use such concepts.
This is because it reduces the time taken avoiding repetitive implementations of an algorithm for specific datatypes while at the same time reducing the risk of creating new bugs.
However, the state of the current literature is that it is often written targeting academics using abstract concepts with extensive use of type theory and complex features of dependent types.
For example, it is not uncommon to find many syntactic short cuts introduced in the literature\,\autocite{Chapman:2010:GAL:1863543.1863547,mcbride2010ornamental}.
While this is something that makes it easier to write complex expressions, it comes at the price of making it harder to immediately understand the underlying concepts for ordinary programmers.

One of my aims was therefore to present a more practical tutorial (see Chapter~\ref{cha:GenericProgramming}), focusing on using the existing theory to build an intuition on how descriptions work.
Therefore, I had chosen to omit all but the necessary parts of type theory, and instead focusing on generic programming as something that relates to the \textit{structuring} of datatypes.
I had started by analysing how a typical datatype is structured, and then showed how to convert datatypes to descriptions starting with the simple \tttype{()} type, then progressing towards more complex indexed types such as \tttype{Vec}~\ttvar{a}~\ttvar{n}.
After providing an intuition on how to build descriptions for commonly used datatypes, I started explaining more complex concepts such as how to provide an informative encoding of constructor tags and how to synthesise actual types from provided descriptions.
Finally, I related the presented encoding back to the literature and provided the motivation on why the encoding was presented in that particular fashion.

Another aim was to make it easy for programmers to use library-provided generic programs without requiring extensive knowledge on how descriptions worked.
Therefore, I provided a way to generate descriptions from ordinary datatype declarations as presented in Chapter~\ref{cha:LevitatingIdris}.
Furhermore, relevant aliases was provided to use these types that were synthesised from the generated descriptions in order to make it possible to use these described types with the same ease as using ordinary datatypes.

Chapter~\ref{cha:PracticalExamples} provided a few realistic functions to present how it was possible to do generic programming using described types.
These were meant to serve as an inspiration for the ordinary programmer, on how to structure commonly used operations in a generic fashion.

Nevertheless, there are still some challenges ahead before generic programming is viable to become a main stream technique.
One challenge is that the types used in generic programming are very complex, and it requires considerable effort to understand the type signatures for even simple operations.
This is especially troublesome when dealing with type errors. 
Because dependent type systems normalise while elaborating, type errors are usually more complex and often contains full expansion of terms, even if abstractions like aliases were used.
It is therefore important to provide a way to present understandable error messages in the future.
Perhaps, one way could be by collapsing some of the erroneous terms into higher-level abstractions when possible.
Another way could be to use techniques such as error reflection\,\autocite{christiansen2014reflect} to simplify and further explain the error messages.
A different challenge is that it might be hard to comprehend all the details of the complete encoding of descriptions at first.
Even though the complete encoding is required to support all the various kinds of datatypes, it might be beneficial if different ``views'' of the description could be presented.
This should make it easier to understand essential features, maybe at the cost of limiting the number of datatypes supported.
For example, one might provide a view that makes generic programming easier for ordinary datatypes by eliding details used for describing indices.
Perhaps, a way to provide such feature could be by having simpler aliases to the description datatype where the index type was hidden and hardcoded to \tttype{()}.

%\begin{enumerate}
  %\item A pedagogical example-based approach to explaining generic programming and descriptions
  %\item A clarification of the different concepts of parameters
  %\item Interesting transformations using ornaments, etc.
%\end{enumerate}

%\begin{enumerate}
  %\item Understanding complex type signatures
  %\item Views of descriptions
  %\item Better error messages and handling of totality
%\end{enumerate}

\subsection{Usability from the perspective of library implementers}
\label{sub:Usabilityfromtheperspectiveoflibraryimplementers}
Described types provide a way to make algorithms that can form the basis for deriving type class instances.
However, the literature is often scarce on presenting examples in a language that supports practical features, such as type classes or tactics, like Idris.

Therefore, I aimed to implement a small collection of examples containing commonly used operations in Chapter~\ref{cha:PracticalExamples}, both in terms of operations that form the base of type classes like \tttype{Show} and \tttype{DecEq} but also
functions that described purely generic properties like \ttdec{is}.
These examples were written using an open world assumption, and they thus needed to interact with the type class resolution mechanism in order to retrieve the necessary constraints.
Examples like \ttdec{is} even use the tactics-based proof search mechanism to find the correct \tttype{Tag} value given a particular constructors name.
This combination of practical features combined with dependent types, make it simpler for library implementers to provide implementations of generic operations with easy to use interfaces without requiring any modification to the compiler.

While it was shown that it was possible to create many interesting generic algorithms, there were still limitations that were not handled in this project.
Chapter~\ref{cha:PracticalExamples} discussed the challenges that had risen when trying to implement a SYB-style generics library, and therefore it would still be desirable to find an alternative approach to handling generic traversal on datatypes.
Additionally, while the presented description datatypes in Chapter~\ref{cha:GenericProgramming} and Chapter~\ref{cha:LevitatingIdris} were able to handle many kinds of subject datatypes, they could not handle all of them.
In order to be able to leverage described types as a way to avoid boilerplate for all kinds of datatypes, additional work would be required to support for complex type families like the inductive-inductive and inductive-recursive ones.
Finally, future work is required in Idris in order to support higher-order implicit and default arguments in order to be able to mimic datatype definitions exactly by described types.

%\begin{enumerate}
  %\item A wide variety of algorithms were supported both type class oriented, and purely generic
  %\item Generation of description from declarations simplifies the use of these algorithms
%\end{enumerate}

%\begin{enumerate}
  %\item Type class inference for restrictions
  %\item A more accurate model to support complex datatypes
  %\item Implicits, higher-order tactics and automation support
%\end{enumerate}

\subsection{Applicability of optimisations}
\label{sub:Applicabilityofoptimisations}
Generic algorithms would not be of great practical use, if they were orders of magnitude slower than their hand-written counterparts.
Therefore, it is essential that the written generic algorithms get optimised, and the added overhead eliminated.
Unfortunately, most of the existing literature on descriptions is purely theoretically focused and looks mostly at how it is possible to increase the expression of such frameworks.
Unlike its Haskell counterparts, there exist few to no optimisation techniques aiming at improving the performance of generic programs in dependently typed programming.

This was the rationale for one of the important aims of this project, to investigate how it was possible to optimise algorithms that use described types.
Chapter~\ref{cha:OptimizingIdrisforFlight} presented an analysis on what overhead was added by encoding datatypes using descriptions, and used that analysis to present two optimisation techniques.
The first technique added support for erasable arguments in the description, and the other technique presented was the design of an algorithm to specialise datatypes.
The manual application of these algorithm in the case of described \tttype{Vec}~\ttvar{a}~\ttvar{n}, showed it was possible to achieve a result that was very close to using hand-written algorithms on ordinary datatypes.

Since only the design has been sketched out for the presented algorithm, there are still tasks that are left out as future work.
One of these tasks would be do provide an implementation of the designed specialisation algorithm, and then benchmark the resulting code to compare the performance and code size of optimised generic programs to hand-written ones.
Another task would be to investigate what types of binding-time analyses are effective and if there are any heurestics that could be used to further improve performance.
For example, a static finitely enumerable parameter should probably not be split if there is no dependent calculation.
Finally, it could be interesting to investigate how such algorithm could be extended to support polymorphic specialisation, since polymorphism in dependent type system is usually a more loose term than in regular type system.
Without polymorphic specialisation, it is not possible to specialise datatypes with nested parameters among others, since that would require creating an infinite series of datatypes (one for each nesting of parameters), similarly to the case of indices.


%\begin{enumerate}
  %\item A design for a general transformation scheme using partial evaluation
%\end{enumerate}

%\begin{enumerate}
  %\item Ironing out details of implementation
  %\item Tuning specialisation, complex analysis, heurestics
  %\item Nested parameters
  %\item Advanced inductive families
%\end{enumerate}


\chapter{Conclusion}
\label{cha:Conclusion}
In the \nameref{cha:Intoduction} (Chapter~\ref{cha:Intoduction}) I put forth three different goals: to find and explain a suitable generic representation of datatypes from existing literature, to show how this representation can be used in practical contexts and to perform optimisation such that generic programming is a viable option in realistic programs.

For the first goal, I had been inspired by the latest research\,\autocite{Chapman:2010:GAL:1863543.1863547,Dagand2013acosmology,diehl2014eliminators} and made a description for datatypes that is suitable to use in the context of Idris.
I had focused on providing a detailed and peer-oriented tutorial, with a less steep learning curve than provided by the literature.
Furthermore, I had extended a version of the description datatype to support more advanced constructs like nested parameters which correctly ensured parametricity by construction.
Finally, I had provided a way to generate the necessary constructs to work with described types like constructor labels, descriptions, and suitable aliases.
While there were still minor usability challenges to overcome, I believe that the presented contributions should make it easier for programmers inexperienced with generic programming to leverage the power of described types.

For the second goal, I had provided a fully-fledged generic implementation of three commonly used algorithms: pretty printing, decidable equality and functorial map.
Additionally, I had abstracted commonly used patterns using purely generic algorithms and showed how it is possible to combine generic programs with practical features such as tactics in Idris.
In the end, I also presented a detailed analysis along with informal justification of why it would be hard to implement a SYB-style library in a dependent typed programming language.
I believe that these contributions, had shed some more light on the possibilities and limitations of the generic programming approach, and shows that it may require some considerations for future library implementers and language designers.

For the final goal, I had analysed the overhead contributed by the generic encoding of datatypes and presented two techniques to eliminate that overhead.
The first technique was an extension to the described types framework with an annotation to support erasure of arguments.
The second technique was an algorithm that specialised datatypes by their static parameters, which I had designed with inspiration from the world of partial evaluation.
While an actual implementation still needs to be developed, application of the algorithm by hand showed that it was possible to eliminate virtually all overhead of the described types in terms of both space usage and runtime performance.

\printbibliography

\chapter{Generation function}
\label{cha:Generation function}
\lstinputlisting[language=Haskell,breaklines=true,numbers=left,caption={Generating relevant functions for working with described types},label={app:gendesc}]{Code/DescriptionGeneration.hs}
\end{document}
